在上一节课中 我们创造了一种reducer组合模式 在模式中一个reducer可以被另外一个reducer调用 进行数组中元素的更新

如果我们带着这个reducer创建一个store并且记录它的state 我们将发现它的初始state是一个空的todos数组 如果我们发送一个‘ADD_TODO’动作 我们发现相应的todo将被添加到state数组中

如果我们发送另外一个‘ADD_TODO’动作 相对应的todo也将被添加到数组的末尾并发送一个id为0的‘TOGGLE_TODO’的动作 将标记id为0的todo的completed属性

在一个简单的示例中将应用的整个state表示成一个todos数组没有什么问题 但如果我们想要存储更多信息呢？例如 我们可能想要让用户根据显示过滤器比如‘SHOW_COMPLETED’ ‘SHOW_ALL’ 或者 ‘SHOW_ACTIVE’来选择哪些todo是当前可见的

显示过滤器的state用一个简单的字符串来表示当前过滤器 它通过‘SET_VISIBILITY_FILTER’动作来改变

为了存储这个新的信息 我不需要改变已经存在的reducers 我将使用reducer组合模式 创建一个新的reducer来调用已经存在的reducers来管理它的大部分状态 并且将结果合并到一个单独的state对象里面

现在第一次运行它，将传递undefined作为子reducers的state 因为组合reducer的初始state是一个空的对象 所以它的所有属性都是undefined 这使得第一次执行时子reducers返回它们的初始state并且归并到state对象中

当一个动作进来时 它调用了reducers并传递了他们管理的state 同时动作将结果合并到一个新的state对象中

这是另外一个reducer组合模式的例子 但这一次我们使用它将多个reducers组合成一个单独的reducer以便我们用来创建我们的store 组合后的reducer初始state现在包含独立reducers的初始state 每当动作到来时 那些reducers将独立处理这些动作

这个模式有助于减少Redux的开发量 因为同一个团队中的不同人们可以在不同的reducers中工作 在处理相同动作时无需进入各自的领域并且同时可以避免合并的冲突

最后 我将发送‘SET_VISIBILITY_FILTER’动作 你可以看到它并不影响todos 但是“显示过滤器”属性将被更新
