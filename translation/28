In the previous lesson, we used the "connect" function from "react-edux" bindings library to generate the container component that renders our presentational component. 
在上节课中，我们使用了 react-redux 库中的 connect() 函数来生成容器组件，这个容器组件负责渲染我们的展示组件。

I specify how to calculate the props to inject from the current Redux store state and the callback props to inject from the "dispatch" function on the Redux store.
我降到了，如何从当前的 Redux store 状态，计算出要注入的属性；以及从 Redux Store 的 dispatch() 函数，计算出要注入的回调函数属性。

Normally, I would keep these functions, called "mapStateToProps" and "mapDispatchToProps". 
通常，我会保留这些被命名为 mapStateToProps() 和 mapDispatchToProps() 的函数。

But I'm working in a single file right now. And I need to write these functions for your other container components, so I'm going to rename them to something more specific, which you don't have to do in your code if you keep every component in its own file.
但是我现在是在单个文件里写代码，我还需要为它的容器组件写这些函数，所以我要将它们命名得更具体一点。在你的代码里，如果你将每一个组件都放在一个单独的文件里，那么你就不需要这样做。

I will also remove the line breaks here to make it clear that these functions are only relevant for generating this particular container component.
我还要把这些换行符去掉，这样看起来代码更清晰，因为这些函数只是为了用来生成这个特定的容器组件。

Now I'm scrolling up to the "AddTodo" component, which is not clearly presentational or a container component. 
现在我要回到 AddTodo 组件，它现在的角色有点模棱两可，不知道是展示组件还是容器组件。

However, it uses the store. 
不过，它用到了 store。

It reads the store from the context to dispatch an action when the button is clicked. 
当一个按钮被点击时，AddTodo 组件从上下文读取了 store，然后分发了一个动作。 

And it has to declare the "contextTypes" to be able to grab the store from the context.
而且它必须声明 contextTypes 来从上下文获取 store。

Context is an unstable API, so it's best to avoid using it in your application code. 
Context 是一个不稳定的 API，所以在你最好避免使用它。 

Instead of reading the store from the context, I will read the "dispatch" function from the props because I only need the "dispatch" here. I don't need the whole store.
现在我不再从上下文读取 store，而是从属性里读取 dispatch() 函数，因为这里我只需要用到 dispatch()。我不需要整个 store。

And I will create a container component with "connect" that will inject the "dispatch" function as a prop. 
现在我要用 connect() 创建一个容器组件，connect() 会将 dispatch() 注入组件作为它的属性。

I will remove the "contextTypes" because the component generated by "connect" function will take care of reading the store from the context.
我要删掉 contextTypes，因为用 connect() 函数生成的组件会搞定从上下文读取 store 这个事情。 

Because I changed the "AddTodo" declaration from the const to the let binding, I can reassign it now so that the consuming component does not need to specify the "dispatch" prop because it will be injected by the component generated by the "connect" code.
因为我将 AddTodo 的声明从 const 改成了 let，所以我可以在这里再次赋值，而不需要给它声明 dispatch 属性。因为 connect() 会在所生成的组件里注入 dispatch。

The first argument to the "connect" function is "mapStateToProps", but there aren't any props for "AddTodo" component that depend on the current state, so I return an empty object. 
connect() 函数的第一个参数是 mapStateToProps，但因为 AddTodo 组件没有依赖任何依赖当前状态的属性，所以这里这是返回一个空对象。

The second argument to "connect" is "mapDispatchToProps", but "AddTodo" component doesn't need any callback props. 
connect() 函数的第二个参数是 mapDispatchToProps。不过 AddTodo 组件不需要任何回调属性。

It just accepts the "dispatch" function itself, so I'm returning it as a prop with the same name.
它只接受 dispatch() 函数本身，所以我只要返回一个对象，其中的 dispatch 属性就是这个 dispatch() 函数。 

Finally, I'm calling the function for a second time to specify the component I want to wrap, in this case, "AddTodo" itself. 
最后，我要对我想要打包的组件，也就是 AddTodo，再次调用这个函数。

The generated container component will not pass any props dependent on the state, but it will pass "dispatch" itself as a function so that the component can read it from the props and use it without worrying about context or specifying "contextTypes".
这样生成的容器组件不会传递任何依赖于状态的属性，但是它会将 dispatch 作为一个函数传递，这样组件就可以从属性里面读取它，而不需要担心上下文或者声明 contextTypes。

However, it is wasteful to even subscribe to the store if we don't calculate any props from the state. 
但是，如果我们不需要用到任何状态里面的属性，那么订阅到 store 其实是很多余的。

So I'm replacing the "mapStateToProps" function with an "null", which tells "connect" that there is no need to subscribe to the store.
所以我将 mapStateToProps 改成 null，这样的话 connect  就不会帮我订阅 store。

Additionally, it's pretty common pattern to inject just the "dispatch" function. 
另外，只注入 dispatch() 函数其实是一个蛮普遍的做法。

So this is why if you specify "null" or any falsy value in "connect" as the second argument, you're going to get "dispatch" injected as a prop. 
所以这也是为什么在 connect() 里面将第二个参数设为 null 或者任何假值，它就会将 dispatch 作为属性注入。

So in fact, I can just remove all arguments here. 
所以，实际上，我可以删掉这里所有的参数。

And the default behavior will be to not subscribe to the store and to inject just the "dispatch" function as a prop.
而这样做，默认地就会不订阅 sotre，以及将 dispatch 函数作为属性注入。

Let's recap what happens to the components here. The "AddTodo" component that I declare accepts "dispatch" as a prop, but it doesn't know how to get the store. It just hopes that someone is going to pass the "dispatch" to it.
让我们来回顾一下在组件身上发生了什么。AddTodo 组件接受 dispatch 作为属性，但它并不需要知道怎么拿到 store。它只是希望有人会将 dispatch 传递给它。

The "connect" code without any arguments is going to generate a container component that does not subscribe to the store. 
不带任何参数地调用 connect() 函数会生成一个不订阅 store 的容器组件。

However, that will pass "dispatch" to the component that it wraps. And in this case, it wraps my "AddTodo" component.
不过，它会将 dispatch 传递给它所包裹的组件。在我们的例子中，就是 AddTodo 组件。

The second "connect" call returns the generated container component. And I'm assigning it to "AddTodo". 
第二个 connect() 调用会返回生成的容器组件。我将它赋值给 AddTodo。

So I'm reassigning the let binding the second time.
所以在这里我对 AddTodo 进行第二次赋值。

And when the further code references "AddTodo", it's going to reference the container component that does not need the "dispatch" prop and that will pass the "dispatch" prop to my inner "AddTodo" component that I don't have a reference to anymore.
而当其他的代码再次应用 AddTodo 时，它们引用的就是那个不需要 dispatch 属性的容器组件，这个组件会将 dispatch 属性传递给我内部的 AddTodo 组件，而这个组件我将无法再次引用。
