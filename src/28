In the previous lesson, we used the "connect" function from "react-edux" bindings library to generate the container component that renders our presentational component. I specify how to calculate the props to inject from the current Redux store state and the callback props to inject from the "dispatch" function on the Redux store.

Normally, I would keep these functions, called "mapStateToProps" and "mapDispatchToProps", but I'm working in a single file right now. And I need to write these functions for your other container components, so I'm going to rename them to something more specific, which you don't have to do in your code if you keep every component in its own file.

I will also remove the line breaks here to make it clear that these functions are only relevant for generating this particular container component.

Now I'm scrolling up to the "AddTodo" component, which is not clearly presentational or a container component. However, it uses the store. It reads the store from the context to dispatch an action when the button is clicked. And it has to declare the "contextTypes" to be able to grab the store from the context.

Context is an unstable API, so it's best to avoid using it in your application code. Instead of reading the store from the context, I will read the "dispatch" function from the props because I only need the "dispatch" here. I don't need the whole store.

And I will create a container component with "connect" that will inject the "dispatch" function as a prop. I will remove the "contextTypes" because the component generated by "connect" function will take care of reading the store from the context.

Because I changed the "AddTodo" declaration from the const to the let binding, I can reassign it now so that the consuming component does not need to specify the "dispatch" prop because it will be injected by the component generated by the "connect" code.

The first argument to the "connect" function is "mapStateToProps", but there aren't any props for "AddTodo" component that depend on the current state, so I return an empty object. The second argument to "connect" is "mapDispatchToProps", but "AddTodo" component doesn't need any callback props. It just accepts the "dispatch" function itself, so I'm returning it as a prop with the same name.

Finally, I'm calling the function for a second time to specify the component I want to wrap, in this case, "AddTodo" itself. The generated container component will not pass any props dependent on the state, but it will pass "dispatch" itself as a function so that the component can read it from the props and use it without worrying about context or specifying "contextTypes".

However, it is wasteful to even subscribe to the store if we don't calculate any props from the state. So I'm replacing the "mapStateToProps" function with an "null", which tells "connect" that there is no need to subscribe to the store.

Additionally, it's pretty common pattern to inject just the "dispatch" function. So this is why if you specify "null" or any falsy value in "connect" as the second argument, you're going to get "dispatch" injected as a prop. So in fact, I can just remove all arguments here. And the default behavior will be to not subscribe to the store and to inject just the "dispatch" function as a prop.

Let's recap what happens to the components here. The "AddTodo" component that I declare accepts "dispatch" as a prop, but it doesn't know how to get the store. It just hopes that someone is going to pass the "dispatch" to it.

The "connect" code without any arguments is going to generate a container component that does not subscribe to the store. However, that will pass "dispatch" to the component that it wraps. And in this case, it wraps my "AddTodo" component.

The second "connect" call returns the generated container component. And I'm assigning it to "AddTodo". So I'm reassigning the let binding the second time.

And when the further code references "AddTodo", it's going to reference the container component that does not need the "dispatch" prop and that will pass the "dispatch" prop to my inner "AddTodo" component that I don't have a reference to anymore.
