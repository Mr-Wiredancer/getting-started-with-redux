1
00:00:00,000 --> 00:00:01,580
在上一课中

2
00:00:01,580 --> 00:00:04,520
我把 Link 这个展示型组件

3
00:00:04,520 --> 00:00:07,280
由 FilterLink 容器组件中分离出来了

4
00:00:07,280 --> 00:00:09,500
FilterLink 容器订阅 Redux store

5
00:00:09,500 --> 00:00:14,260
并提供渲染 Link 所需要的数据和行为

6
00:00:14,260 --> 00:00:18,360
虽然这个做法让数据流变得不太明显

7
00:00:18,600 --> 00:00:22,040
但这能让 FilterLink 轻易地被任何组件使用

8
00:00:22,060 --> 00:00:28,360
而不用担心传递额外数据给它或者其父元素

9
00:00:28,740 --> 00:00:33,180
在这一课我们会继续从最上层的容器组件中

10
00:00:33,180 --> 00:00:35,480
抽离出其他容器组件

11
00:00:35,480 --> 00:00:38,540
第一个候选就是 TodoList 组件

12
00:00:39,300 --> 00:00:43,980
我打算保持 TodoList 为展示型组件

13
00:00:43,980 --> 00:00:48,560
然而我想把当前可见的 todo

14
00:00:48,560 --> 00:00:51,140
都封装在一个独立的容器组件里

15
00:00:51,140 --> 00:00:54,620
这个组件会把 TodoList 和 Redux store 连接起来

16
00:00:54,620 --> 00:00:58,620
我将这个组件命名为 VisibleTodoList

17
00:00:58,940 --> 00:01:03,400
就像在上一课定义 FilterLink 的时候

18
00:01:03,540 --> 00:01:11,140
我用 Redux store 的状态去计算数据一样

19
00:01:11,140 --> 00:01:14,820
这里我用 getVisibleTodos 函数

20
00:01:14,820 --> 00:01:17,600
去获取当前可见的那些 todo

21
00:01:17,600 --> 00:01:21,100
它会基于 Redux store 里面所有的 todos

22
00:01:21,100 --> 00:01:24,980
以及当前的可见过滤器做出计算

23
00:01:25,120 --> 00:01:27,820
我还要指定行为

24
00:01:27,820 --> 00:01:30,280
如果一个 todo 被点击

25
00:01:30,280 --> 00:01:33,500
我们应该分发一个“TOGGLE_TODO”的动作

26
00:01:33,500 --> 00:01:36,160
动作还包含被点击的 todo 的 ID

27
00:01:36,660 --> 00:01:39,000
所有的容器组件都类似

28
00:01:39,000 --> 00:01:44,520
他们的职责就是连接展示型组件和 Redux store

29
00:01:44,520 --> 00:01:48,640
并为展示型组件提供所需的行为和数据

30
00:01:49,280 --> 00:01:53,900
我滚动到上节课写的 FilterLink 容器组件

31
00:01:53,900 --> 00:01:57,020
复制粘贴他的 store 订阅逻辑

32
00:01:57,020 --> 00:01:59,020
就像 FilterLink

33
00:01:59,020 --> 00:02:02,260
VisibleTodoList 会订阅 store

34
00:02:02,260 --> 00:02:08,740
并在每次状态改变时会强制用新的状态重新渲染

35
00:02:09,120 --> 00:02:12,960
现在 VisibleTodoList 已经和 Redux store 连接一起

36
00:02:12,960 --> 00:02:15,200
我们可以用它替代 TodoList

37
00:02:15,200 --> 00:02:18,800
这样我们不再需要由最上面传递所有的属性

38
00:02:19,940 --> 00:02:21,720
最后  在上一节课中

39
00:02:21,720 --> 00:02:24,500
我把 AddTodo 改成了展示型组件

40
00:02:24,500 --> 00:02:27,120
现在我要反悔了

41
00:02:27,760 --> 00:02:34,160
我要复制粘贴分发回调到组件里面的 onClick 处理器

42
00:02:34,160 --> 00:02:38,780
因为这里实在没有多少展示或者行为

43
00:02:38,780 --> 00:02:40,780
在我们知道怎么分离它们之前

44
00:02:40,780 --> 00:02:43,940
把它们放一起更简单

45
00:02:43,940 --> 00:02:48,760
比如   在未来我们可能会有一个 Form 组件

46
00:02:48,760 --> 00:02:51,800
那时候会分离  但现在就算了

47
00:02:52,720 --> 00:02:55,580
我向下滚动到 TodoApp 组件

48
00:02:55,580 --> 00:02:58,000
我移除了 onAddClick 属性

49
00:02:58,000 --> 00:03:03,760
我发现没有一个容器需要以属性传递状态

50
00:03:03,760 --> 00:03:07,580
所以我可以移除所有 TodoApp 的属性

51
00:03:07,580 --> 00:03:10,200
并且我可以移除 render() 函数

52
00:03:10,200 --> 00:03:14,840
该函数利用当前 store 状态来渲染 TodoApp

53
00:03:14,840 --> 00:03:17,140
我可以只调用它一次

54
00:03:17,140 --> 00:03:20,680
移除所有和状态有关的属性

55
00:03:20,680 --> 00:03:28,560
因为渲染出来的容器组件会各自去对 store 产生订阅

56
00:03:28,700 --> 00:03:32,580
并响应 store 状态改变自动更新

57
00:03:33,580 --> 00:03:39,320
我们回顾分离展示组件和容器组件后的数据流

58
00:03:39,800 --> 00:03:43,520
现在只有一个 React.render 在最后被调用

59
00:03:43,520 --> 00:03:46,900
当 store 改变时  我们不需要再重复渲染

60
00:03:47,080 --> 00:03:49,880
因为容器组件会自己去渲染

61
00:03:50,560 --> 00:03:53,980
我在看的第一个组件叫做 AddTodo

62
00:03:53,980 --> 00:03:58,620
我把它归类为展示型组件

63
00:03:58,620 --> 00:04:00,620
或者容器组件都可以

64
00:04:00,620 --> 00:04:03,620
因为它两者都不太符合

65
00:04:03,620 --> 00:04:07,380
输入栏和按钮属于展示的部分

66
00:04:07,620 --> 00:04:10,980
但是点击的动作分发是行为

67
00:04:10,980 --> 00:04:13,360
它通常由容器来指定

68
00:04:13,540 --> 00:04:16,500
但在这个例子我更愿意把它们放一起

69
00:04:16,500 --> 00:04:18,620
因为这里没有任何状态

70
00:04:18,620 --> 00:04:20,620
UI 也很简单

71
00:04:20,620 --> 00:04:25,920
很难想象会有除了分发 "ADD_TODO“ 以外的动作

72
00:04:28,720 --> 00:04:33,420
第二个在 TodoApp 里面的组件叫 VisibleTodoList

73
00:04:33,660 --> 00:04:37,080
现在他是个真正意义上的容器组件

74
00:04:37,140 --> 00:04:39,040
它对 store 进行订阅

75
00:04:39,040 --> 00:04:44,220
并在 store 变化时重新渲染 TodoList

76
00:04:44,560 --> 00:04:46,780
它根据当前的 Redux store 状态

77
00:04:46,880 --> 00:04:49,040
所有的 todo 以及 visibilityFilter 的值

78
00:04:49,200 --> 00:04:51,560
来计算可见的那些 todo

79
00:04:51,760 --> 00:04:53,980
并且把结果以 todos 变量的方式来传递

80
00:04:54,200 --> 00:04:56,140
当 todos 被点击时

81
00:04:56,140 --> 00:04:58,540
它会分发一个“TOGGLE_TODO”动作

82
00:04:58,540 --> 00:05:02,900
动作中包含该 todo 的 ID

83
00:05:03,680 --> 00:05:07,480
这里的实际渲染由 TodoList 组件负责

84
00:05:07,480 --> 00:05:10,380
它渲染所有由属性传进来的 todos

85
00:05:10,380 --> 00:05:13,660
并用 onTodoClick 绑定它们的点击

86
00:05:14,480 --> 00:05:18,280
最后一个在 TodoApp 里面的组件是 Footer

87
00:05:18,280 --> 00:05:21,760
Footer 只是一个展示型组件

88
00:05:21,760 --> 00:05:24,340
它渲染三个 FilterLink

89
00:05:25,260 --> 00:05:27,980
FilterLink 是容器组件

90
00:05:27,980 --> 00:05:30,200
所以它订阅 store

91
00:05:30,300 --> 00:05:34,000
并渲染 Link 展示型组件

92
00:05:34,340 --> 00:05:37,000
它会由 Redux store 的状态

93
00:05:37,120 --> 00:05:40,320
和 props 计算 Link 是否为 active

94
00:05:40,320 --> 00:05:44,060
并为 Link 指定点击的行为

95
00:05:45,140 --> 00:05:49,220
最后   link 组件只是展示型组件

96
00:05:49,220 --> 00:05:51,220
它用于渲染 a 标签

97
00:05:52,000 --> 00:05:57,260
分离容器和展示型组件通常是个好主意

98
00:05:57,260 --> 00:05:59,540
但你别把这当做个教条

99
00:05:59,680 --> 00:06:04,060
除非这样做真的能降低你代码的复杂度

100
00:06:04,360 --> 00:06:09,460
总而言之   我建议先尝试抽出展示型组件

101
00:06:09,460 --> 00:06:13,240
如果传递属性造成太多重复性代码

102
00:06:13,240 --> 00:06:19,660
那你可以考虑创建容器去加载数据和指定行为

