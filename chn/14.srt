1
00:00:00,250 --> 00:00:01,400
在上一节中

2
00:00:01,400 --> 00:00:04,400
我们建立了一种 reducer 组合模式

3
00:00:04,400 --> 00:00:07,270
在模式中 一个 reducer 可以被另外一个 reducer 调用

4
00:00:07,270 --> 00:00:09,700
进行数组中元素的更新

5
00:00:10,420 --> 00:00:13,820
如果我们使用这个 reducer 去创建一个 store 并打印出它的 state

6
00:00:14,000 --> 00:00:18,570
我们将发现它的初始 state 是一个空的 todos 数组

7
00:00:18,650 --> 00:00:21,450
如果我们分发一个‘ADD_TODO’动作

8
00:00:21,450 --> 00:00:26,000
我们会发现相应的 todo 将被添加到 state 数组中

9
00:00:26,470 --> 00:00:29,000
如果我们发送另外一个‘ADD_TODO’动作

10
00:00:29,000 --> 00:00:32,720
相对应的 todo 也将被添加到数组的末尾

11
00:00:32,820 --> 00:00:35,050
还有分发一个 id 为 0 的‘TOGGLE_TODO’的动作

12
00:00:35,050 --> 00:00:40,170
会翻转 id 为 0 的 todo 的 completed 字段

13
00:00:40,920 --> 00:00:43,450
在一个简单的示例中

14
00:00:43,470 --> 00:00:47,020
将应用的整个 state 表示成一个 todos 数组没有什么问题

15
00:00:47,070 --> 00:00:50,100
但如果我们想要存储更多信息呢？

16
00:00:50,250 --> 00:00:54,820
例如 我们可能想要让用户通过“显示过滤器”

17
00:00:54,820 --> 00:00:59,870
比如‘SHOW_COMPLETED’ ‘SHOW_ALL’ 或者 ‘SHOW_ACTIVE’来选择哪些 todo 是当前可见的

18
00:01:00,370 --> 00:01:05,350
显示过滤器的 state 用一个简单的字符串来表示当前过滤器

19
00:01:05,350 --> 00:01:08,600
它通过‘SET_VISIBILITY_FILTER’动作来改变

20
00:01:09,100 --> 00:01:10,770
为了存储这个新的信息

21
00:01:10,770 --> 00:01:13,770
我不需要改变已经存在的 reducers

22
00:01:13,950 --> 00:01:16,550
我将使用 reducer 组合模式

23
00:01:16,550 --> 00:01:20,670
创建一个新的 reducer 来调用已经存在的 reducers

24
00:01:20,670 --> 00:01:22,550
来管理它的不同部分的状态

25
00:01:22,550 --> 00:01:25,820
并且将结果合并到一个单独的 state 对象里面

26
00:01:26,320 --> 00:01:28,050
现在第一次运行它

27
00:01:28,050 --> 00:01:31,650
将传递 undefined 作为子 reducers 的 state

28
00:01:31,770 --> 00:01:35,250
因为组合 reducer 的初始 state 是一个空的对象

29
00:01:35,250 --> 00:01:37,720
所以它的所有属性都是 undefined

30
00:01:38,200 --> 00:01:42,220
这使得第一次执行时 子 reducers 返回它们的初始 state

31
00:01:42,220 --> 00:01:45,300
并且填充到 state 对象中

32
00:01:45,670 --> 00:01:46,870
当一个传递动作进来时

33
00:01:46,870 --> 00:01:52,020
它调用了全部 reducer 并把他们管理的对应的 state 部分和动作传递进去

34
00:01:52,020 --> 00:01:55,420
然后将结果合并到一个新的 state 对象中

35
00:01:56,100 --> 00:01:59,520
这是另外一个 reducer 组合模式的例子

36
00:01:59,520 --> 00:02:04,420
但这一次我们使用它将多个 reducers 组合成一个单独的 reducer

37
00:02:04,420 --> 00:02:06,950
我们用它来创建我们的 store

38
00:02:07,850 --> 00:02:13,670
组合后的 reducer 初始 state 现在包含独立 reducers 的初始state

39
00:02:13,670 --> 00:02:15,670
每当动作到来时

40
00:02:15,670 --> 00:02:19,400
那些reducers将独立处理这些动作

41
00:02:20,320 --> 00:02:23,400
这个模式使 Redux 开发更具扩展性

42
00:02:23,400 --> 00:02:27,500
因为在团队中的不同的人可以去开发不同的 reducer

43
00:02:27,500 --> 00:02:30,950
在处理相同动作时不会产生冲突

44
00:02:30,950 --> 00:02:32,600
还能避免合并（代码）的冲突

45
00:02:33,750 --> 00:02:37,120
最后 我将分发‘SET_VISIBILITY_FILTER’动作

46
00:02:37,220 --> 00:02:39,570
你可以看到它并不影响 todos

47
00:02:39,570 --> 00:02:41,570
但是“显示过滤器”字段被更新了。

