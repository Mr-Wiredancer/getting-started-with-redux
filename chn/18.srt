1
00:00:00,200 --> 00:00:01,250
在上节课

2
00:00:01,250 --> 00:00:05,570
我们为 todo 列表应用实现了一个简单的 UI

3
00:00:05,850 --> 00:00:08,320
可以添加新的 todo

4
00:00:08,320 --> 00:00:10,950
查看已存在的 todo

5
00:00:11,450 --> 00:00:12,600
为了添加新的 todo

6
00:00:12,600 --> 00:00:14,870
我们发起了 ADD_TODO 动作

7
00:00:14,970 --> 00:00:15,870
在这节课

8
00:00:15,870 --> 00:00:18,520
我们将通过点击 todo

9
00:00:18,520 --> 00:00:23,020
发起 TOGGLE_TODO 的动作来切换 todo 的已完成状态

10
00:00:23,850 --> 00:00:26,300
我往下滚动到 ( 定义 ) 我的 React 组件的地方

11
00:00:26,300 --> 00:00:30,100
在这里我得到一个 todo 对应的列表元素

12
00:00:30,100 --> 00:00:32,670
所以我 ( 在这 ) 添加一个 onClick 的处理方法

13
00:00:32,670 --> 00:00:36,070
当用户单击列表元素时

14
00:00:36,070 --> 00:00:38,920
我想发起一个动作到 store 中

15
00:00:38,920 --> 00:00:40,620
它具有 TOGGLE_TODO 的类型

16
00:00:40,620 --> 00:00:43,350
并且还有即将被切换 ( 已完成状态 ) 的 todo 的 id

17
00:00:43,350 --> 00:00:45,570
id 从这个 todo 对象中得到

18
00:00:46,850 --> 00:00:50,050
这个事件处理方法知道它所对应的 todo

19
00:00:50,050 --> 00:00:53,020
所以它能够在动作中传递它 ( todo ) 的 id

20
00:00:54,050 --> 00:00:55,350
在用户界面上

21
00:00:55,350 --> 00:00:58,870
我想让已完成的 todo 显示成删除的样子

22
00:00:58,870 --> 00:01:02,820
所以我为这个列表元素添加 style 属性

23
00:01:02,970 --> 00:01:06,950
我将使用 textDecoration 属性

24
00:01:07,150 --> 00:01:09,950
当 todo 的已完成状态为真时

25
00:01:09,950 --> 00:01:12,270
它的值为 line-through

26
00:01:12,420 --> 00:01:13,920
当 todo 的已完成状态为假时

27
00:01:13,920 --> 00:01:15,570
它的值为 none

28
00:01:15,570 --> 00:01:18,450
所以现在我得到看上去正常的 todo

29
00:01:18,820 --> 00:01:21,700
现在，如果我添加一些 todo

30
00:01:21,700 --> 00:01:23,350
我可以点击它们

31
00:01:23,350 --> 00:01:25,920
它们的状态会被切换

32
00:01:25,920 --> 00:01:27,600
我还可以把它们的状态切换回来

33
00:01:29,770 --> 00:01:31,320
还不错吧

34
00:01:31,800 --> 00:01:34,720
让我们来回顾一下切换 todo ( 的状态 ) 究竟是怎么工作的

35
00:01:35,620 --> 00:01:40,550
它是从我的点击处理方法中发起 TOGGLE_TODO 的动作开始的

36
00:01:40,550 --> 00:01:42,370
这个动作具有 TOGGLE_TODO 的类型

37
00:01:42,370 --> 00:01:46,620
和当前正在被渲染的 todo 的 id

38
00:01:47,000 --> 00:01:49,370
在渲染所有 todo 的 render 方法中

39
00:01:49,370 --> 00:01:54,850
我从数组的 map 回调函数中得到作为参数的 todo 对象

40
00:01:56,050 --> 00:01:57,550
当一个动作被分发

41
00:01:57,550 --> 00:01:59,750
store 将会调用根 reducer

42
00:01:59,870 --> 00:02:02,420
根 reducer 又将会调用 todos reducer

43
00:02:02,420 --> 00:02:05,320
来处理 todos 数组和此动作在这个例子中

44
00:02:05,570 --> 00:02:08,370
在这个例子中 这个动作的类型是 TOGGLE_TODO

45
00:02:08,570 --> 00:02:11,270
所以 todos reducer 以代理的方式

46
00:02:11,270 --> 00:02:18,300
在 map 函数中调用 todo reducer 来处理每一个 todo

47
00:02:18,370 --> 00:02:22,700
所以 todo reducer 接收 todo 作为状态

48
00:02:22,700 --> 00:02:23,920
还接收动作

49
00:02:24,470 --> 00:02:26,470
我们继续对比动作的类型

50
00:02:26,470 --> 00:02:28,920
它匹配 TOGGLE_TODO 字符串

51
00:02:29,320 --> 00:02:35,170
现在，对于每一个和动作中指定的 id 不匹配的 todo

52
00:02:35,170 --> 00:02:37,170
我们就返回之前的状态

53
00:02:37,170 --> 00:02:39,720
即原来的 todo 对象

54
00:02:39,870 --> 00:02:45,350
然而，如果 todo 的 id 和动作中指定的 id 相匹配

55
00:02:45,350 --> 00:02:47,550
我们将返回一个新的对象

56
00:02:47,550 --> 00:02:50,300
它具有原来 todo 所有的属性

57
00:02:50,300 --> 00:02:55,270
但是 completed 字段的值和原来是相反的

58
00:02:55,920 --> 00:03:02,470
更新后的 todo 元素将会被包含在应用的新状态的 todos 字段中

59
00:03:02,670 --> 00:03:05,650
而且因为我们订阅了 render 方法

60
00:03:05,650 --> 00:03:10,000
它将从 store.getState() 中得到应用的下一状态

61
00:03:10,000 --> 00:03:14,550
然后将新的 todos 传递给 TodoApp 组件

62
00:03:14,550 --> 00:03:17,700
TodoApp 组件将渲染更新后的 todos

63
00:03:18,770 --> 00:03:21,220
最后，列表元素的这个 style

64
00:03:21,220 --> 00:03:23,720
和 todo 的 completed 字段绑定

65
00:03:23,720 --> 00:03:25,100
我们刚更新它

66
00:03:25,100 --> 00:03:30,820
这就是为什么它重新渲染时显示删除线

