1
00:00:00,000 --> 00:00:01,080
在前面的课上

2
00:00:01,080 --> 00:00:06,000
我们从主容器组件中分离出表现型组件

3
00:00:06,380 --> 00:00:08,680
由 TodoApp 指定它们的行为

4
00:00:08,680 --> 00:00:11,200
包括点击 “Add Todo” 按钮的行为

5
00:00:11,200 --> 00:00:13,600
todo 列表是怎么被选择的

6
00:00:13,600 --> 00:00:16,460
点击一个单独的 todo 元素的行为

7
00:00:16,760 --> 00:00:19,440
以及点击底部链接的行为

8
00:00:19,680 --> 00:00:28,640
像 AddTodo  TodoList  Todo  Footer

9
00:00:28,640 --> 00:00:29,880
以及 FilterLink 这些组件

10
00:00:29,880 --> 00:00:31,880
它们不再分发动作

11
00:00:31,880 --> 00:00:33,880
它们只是调用属性中的回调函数

12
00:00:33,880 --> 00:00:38,500
所以它们只负责展示而不负责行为

13
00:00:39,180 --> 00:00:41,100
但这种做法的缺点就是

14
00:00:41,100 --> 00:00:44,200
我需要往下层传递很多属性

15
00:00:44,200 --> 00:00:47,860
尽管有些中间层组件并一定真的需要用到它们

16
00:00:48,200 --> 00:00:51,700
比如   FilterLink 组件需要知道 currentFilter 的值

17
00:00:51,820 --> 00:00:53,440
这样当它被激活时

18
00:00:53,440 --> 00:00:55,440
它可以选择一个不同的展现形式

19
00:00:55,680 --> 00:00:58,500
但是  为了接收 currentFilter

20
00:00:58,500 --> 00:01:01,060
它需要从最顶层被传递下来

21
00:01:01,060 --> 00:01:06,540
这就是为什么 Footer 需要接受 visibilityFilter 作为属性

22
00:01:06,540 --> 00:01:10,160
这样它才能把它作为 currentFilter 属性传递给 FilterLink 组件

23
00:01:10,520 --> 00:01:12,460
在某种程度上，这种做法打破了封装

24
00:01:12,460 --> 00:01:18,880
因为父组件需要知道太多子组件需要的数据

25
00:01:18,980 --> 00:01:20,180
为了解决这个问题

26
00:01:20,180 --> 00:01:23,720
我们将抽取一些额外的容器组件

27
00:01:23,720 --> 00:01:27,940
就像在前面的课上抽取表现型组件一样

28
00:01:29,020 --> 00:01:32,980
我想重构的第一个组件是 Footer 组件

29
00:01:33,200 --> 00:01:35,760
目前  它接收两个属性

30
00:01:35,760 --> 00:01:39,180
visibilityFilter 和 onFilterClick 回调

31
00:01:39,380 --> 00:01:42,160
但实际上它并没有使用它们

32
00:01:42,160 --> 00:01:44,620
它只是把它们往下传递给 FilterLink 组件

33
00:01:44,740 --> 00:01:48,440
看起来这是个简化的好机会

34
00:01:50,040 --> 00:01:52,300
我们能做这个是因为我们知道

35
00:01:52,320 --> 00:01:56,180
 Footer 组件不关心这些属性的值

36
00:01:56,180 --> 00:01:58,360
它们存在只是为了往下传递给

37
00:01:58,360 --> 00:02:00,360
真正关心它们的 FilterLink 组件

38
00:02:01,480 --> 00:02:03,720
我现在移除这些属性的定义

39
00:02:03,720 --> 00:02:07,160
我也从 FilterLink 中移除对这些属性的使用

40
00:02:07,500 --> 00:02:14,040
现在可能它开始看上去和分离表现型组件前的代码很相似

41
00:02:14,040 --> 00:02:17,500
但是  在这里我想做的有一点不同

42
00:02:19,060 --> 00:02:24,300
FilterLink 组件现在没有指定点击链接的行为

43
00:02:25,200 --> 00:02:27,100
它也需要 currentFilter 属性

44
00:02:27,100 --> 00:02:29,680
来告诉它是否需要被渲染成激活的样子

45
00:02:30,340 --> 00:02:35,540
因此  说 FilterLink 是一个表现型组件是有一点不诚实的

46
00:02:35,540 --> 00:02:38,900
因为它没有和行为相分离

47
00:02:39,020 --> 00:02:41,940
点击它后唯一合理的反应

48
00:02:41,940 --> 00:02:45,080
就是通过分发动作来设置 visibilityFilter

49
00:02:46,160 --> 00:02:50,480
这就是为什么我把它变成一个不同的表现型组件

50
00:02:50,480 --> 00:02:52,220
我称之为 Link

51
00:02:52,540 --> 00:02:58,000
我将创建另一个 FilterLink 组件作为容器用于渲染

52
00:02:58,660 --> 00:03:02,200
Link 组件不知道任何关于过滤值的内容

53
00:03:02,200 --> 00:03:04,900
它只接受 active 属性

54
00:03:04,900 --> 00:03:07,040
而且调用它自身的 onClick 处理方法

55
00:03:07,040 --> 00:03:09,560
它只关心渲染

56
00:03:09,980 --> 00:03:13,920
然而  我同时也创建另一个组件 FilterLink

57
00:03:14,200 --> 00:03:20,500
这一次它将是一个使用 store 中的当前数据来渲染 Link 组件的类

58
00:03:20,940 --> 00:03:24,060
它将读取组件的属性

59
00:03:24,260 --> 00:03:27,960
而且它也将读取状态   但不是指 react 的状态

60
00:03:28,220 --> 00:03:32,940
而是指通过调用 store.getState() 得到的 Redux store 的状态

61
00:03:33,680 --> 00:03:38,280
作为一个容器组件   FilterLink 没有自己的标记

62
00:03:38,380 --> 00:03:42,940
它代理渲染 Link 表现型组件

63
00:03:43,500 --> 00:03:44,620
在这个例子中

64
00:03:44,740 --> 00:03:47,080
它通过比较它自己的 filter 属性

65
00:03:47,260 --> 00:03:49,660
和 Redux store 状态中的 visibilityFilter

66
00:03:49,660 --> 00:03:52,920
来计算得到 active 属性

67
00:03:53,740 --> 00:03:58,260
filter 属性是从 Footer 传递到 FilterLink 的

68
00:03:58,480 --> 00:04:03,300
visibilityFilter 对应当前被选中的可见过滤值

69
00:04:03,300 --> 00:04:05,580
它被保存在 Redux store 的状态中

70
00:04:05,720 --> 00:04:08,900
如果二者匹配   我们想让 Link 显示成激活的样式

71
00:04:09,480 --> 00:04:13,380
容器组件也需要指定行为

72
00:04:13,380 --> 00:04:14,560
所以在这个例子中

73
00:04:14,560 --> 00:04:19,000
FilterLink 指定当这个特定的 Link 被点击时

74
00:04:19,000 --> 00:04:23,020
我们应该分发一个类型是 SET_VISIBILITY_FILTER 动作

75
00:04:23,020 --> 00:04:26,320
这个动作中还包含从属性中得到的 filter 值

76
00:04:27,320 --> 00:04:29,840
FilterLink 可能接收 children 属性

77
00:04:29,840 --> 00:04:32,880
来用于作为 Link 组件的内容

78
00:04:32,980 --> 00:04:36,560
所以我们将把 children 传递到 Link 组件

79
00:04:36,560 --> 00:04:39,560
我们将把它们渲染在 <a> 标签中

80
00:04:40,220 --> 00:04:43,660
FilterLink 的这个实现存在一个小问题

81
00:04:44,260 --> 00:04:48,260
在 render 方法中  它读取 Redux store 的当前状态

82
00:04:48,480 --> 00:04:51,300
但是   它并没有订阅到 store

83
00:04:51,300 --> 00:04:55,240
以当 store 被更新时   如果父组件没有更新

84
00:04:55,380 --> 00:04:58,260
它将渲染原来的状态值

85
00:04:58,660 --> 00:05:02,640
目前当状态改变时  我们重新渲染整个应用

86
00:05:02,760 --> 00:05:04,780
然而  这不是很有效率

87
00:05:04,780 --> 00:05:05,720
所以将来

88
00:05:05,720 --> 00:05:09,300
我们把订阅到 store 的行为

89
00:05:09,300 --> 00:05:13,120
移到容器组件的生命周期方法中

90
00:05:14,060 --> 00:05:17,020
React 在组件实例中提供一个特别的 forceUpdate() 方法

91
00:05:17,020 --> 00:05:20,560
它用来强制进行重新渲染

92
00:05:20,560 --> 00:05:26,800
这样   任何时候只要 store 的状态值发生改变

93
00:05:26,800 --> 00:05:29,960
我们就强制更新容器组件

94
00:05:30,560 --> 00:05:35,880
我们在 componentDidMount() 生命周期方法中执行订阅

95
00:05:35,880 --> 00:05:41,720
所以在 componentWillUnmount() 方法中取消订阅很重要

96
00:05:42,600 --> 00:05:45,780
注意我们实际上并没有 unsubscribe() 方法

97
00:05:45,780 --> 00:05:49,680
但这是 store.subscribe() 方法的返回值

98
00:05:49,900 --> 00:05:51,020
所以我们可以保存它

99
00:05:51,020 --> 00:05:54,100
然后在 componentWillUnmount() 中调用它

100
00:05:54,900 --> 00:05:56,700
让我们来回顾这部分内容

101
00:05:56,700 --> 00:05:59,880
FilterLink 组件订阅到 store

102
00:05:59,880 --> 00:06:02,980
任何时候 store 发生改变就调用 forceUpdate()

103
00:06:02,980 --> 00:06:05,320
这样它就能渲染 store 的当前状态

104
00:06:05,580 --> 00:06:10,520
它使用 unsubscribe 保存 store.subscribe() 返回的引用

105
00:06:10,740 --> 00:06:14,220
然后当组件需要被卸载时

106
00:06:14,220 --> 00:06:16,220
调用它来清除订阅

107
00:06:16,940 --> 00:06:20,180
让我们来回顾 FilterLink 容器组件和

108
00:06:20,180 --> 00:06:24,300
Link 表现型组件之间的关系

109
00:06:25,560 --> 00:06:31,460
Link 组件只指定了当它处理激活或未激活时的展现形式

110
00:06:31,460 --> 00:06:34,400
但不知道它的行为

111
00:06:35,520 --> 00:06:38,100
FilterLink 组件是一个容器

112
00:06:38,100 --> 00:06:42,740
它为表现型组件提供数据和行为

113
00:06:43,300 --> 00:06:44,400
当它被装载时

114
00:06:44,400 --> 00:06:45,980
它订阅到 store

115
00:06:45,980 --> 00:06:49,900
这样当 store 状态改变时它会独立地重新渲染

116
00:06:49,900 --> 00:06:54,580
因为在它的 render 方法中它需要使用 store 的当前状态

117
00:06:55,600 --> 00:06:58,160
它没有指明 DOM 树的结构

118
00:06:58,160 --> 00:07:02,160
而是把渲染的工作交给了展示组件 Link

119
00:07:02,300 --> 00:07:06,520
它唯一的工作就是根据 FilterLink 自己的属性

120
00:07:06,520 --> 00:07:10,680
和 Redux store 的当前状态来计算 (新的) 属性

121
00:07:10,680 --> 00:07:16,360
而且它也指定了回调用于分发动作到 store

122
00:07:17,440 --> 00:07:19,380
在动作被分发后

123
00:07:19,380 --> 00:07:23,460
store 将会记住由 reducer 返回的新状态

124
00:07:23,460 --> 00:07:26,260
然后它将调用每一个订阅到 store 的订阅者

125
00:07:26,520 --> 00:07:27,560
在这个例子中

126
00:07:27,560 --> 00:07:31,640
每一个 FilterLink 组件实例都订阅到了 store

127
00:07:31,640 --> 00:07:35,760
所以它们将调用它们的 forceUpdate() 方法

128
00:07:35,760 --> 00:07:39,580
它们将根据当前 store 的状态进行重新渲染

129
00:07:41,260 --> 00:07:43,980
FilterLink 是一个容器组件

130
00:07:43,980 --> 00:07:45,980
所以它是完全自主的

131
00:07:46,100 --> 00:07:49,840
而且它可以被用在表现型组件中

132
00:07:49,860 --> 00:07:50,780
比如 Footer 组件

133
00:07:50,860 --> 00:07:55,020
它没有从 store 获取数据作为额外的属性进行传递

134
00:07:55,020 --> 00:07:56,320
也没有指定行为

135
00:07:56,720 --> 00:07:59,560
这让我们保持 Footer 组件足够简单

136
00:07:59,560 --> 00:08:04,440
并且解耦了行为以及它的子组件需要的数据

