1
00:00:00,000 --> 00:00:01,540
在前面的课程中

2
00:00:01,540 --> 00:00:06,280
我们使用这个最顶层的 store 变量来关联 Redux store

3
00:00:06,900 --> 00:00:11,400
访问 store 的组件   比如那些容器组件

4
00:00:11,560 --> 00:00:12,920
它们都使用这个最顶层的 store 变量

5
00:00:12,980 --> 00:00:14,580
从 store 读取状态   订阅 store

6
00:00:14,720 --> 00:00:19,320
以及分发动作到 store

7
00:00:20,100 --> 00:00:22,400
这种方法对于一个 JSBin

8
00:00:22,400 --> 00:00:25,420
这种所有的东西都在一个文件里的例子来说还不错

9
00:00:25,580 --> 00:00:29,540
但是   有几个原因使它不能扩展到真正的应用中

10
00:00:30,280 --> 00:00:33,900
首先   它使你的容器组件很难测试

11
00:00:33,900 --> 00:00:36,560
因为它们关联到了一个具体的 store

12
00:00:36,560 --> 00:00:40,880
但是你可能想在测试中使用一个不同的假的 store

13
00:00:41,700 --> 00:00:47,720
其次   它很难实现在服务器端进行渲染的通用应用

14
00:00:47,720 --> 00:00:49,040
因为在服务器端

15
00:00:49,040 --> 00:00:53,280
你想为每一个请求提供不同的 store 实例

16
00:00:53,280 --> 00:00:55,980
因为不同的请求携带不同的数据

17
00:00:57,300 --> 00:01:02,280
我将开始把创建 store 的代码移到文件底部

18
00:01:02,280 --> 00:01:04,880
就是在渲染我的 React 组件的地方

19
00:01:06,660 --> 00:01:08,440
我将稍微地改变它

20
00:01:08,440 --> 00:01:12,060
我将把创建的 store 作为属性传递给最顶层的组件

21
00:01:12,060 --> 00:01:17,760
替代创建最顶层的 store 变量

22
00:01:17,760 --> 00:01:20,720
这样它是完全可注入的

23
00:01:21,200 --> 00:01:24,720
每一个容器组件都需要一个 store 的引用

24
00:01:24,840 --> 00:01:25,860
所以很不幸

25
00:01:25,860 --> 00:01:29,400
我们需要把它作为属性往下传递给每一个组件

26
00:01:29,860 --> 00:01:32,080
比起传递不同的数据给每一个组件

27
00:01:32,080 --> 00:01:33,600
这样更省力

28
00:01:33,600 --> 00:01:35,260
但它仍然不方便

29
00:01:35,260 --> 00:01:36,200
但是别急

30
00:01:36,200 --> 00:01:38,200
我们之后会找到一个更好的解决办法

31
00:01:38,280 --> 00:01:40,360
但是现在   我们需要看看这个问题

32
00:01:40,780 --> 00:01:43,620
这个问题就是容器组件

33
00:01:43,620 --> 00:01:47,360
需要 store 的实例来获取状态

34
00:01:47,360 --> 00:01:50,200
分发动作和订阅变化

35
00:01:50,200 --> 00:01:51,540
所以这次

36
00:01:51,540 --> 00:01:55,320
我把容器组件改变为使用 ES6 解构语法

37
00:01:55,320 --> 00:01:58,740
从属性中获取 store

38
00:01:58,940 --> 00:02:01,840
这里的意思是 store 等于 props.store

39
00:02:01,840 --> 00:02:03,400
我在这里做同样的操作

40
00:02:03,400 --> 00:02:05,880
我从 props 中获取 store

41
00:02:05,880 --> 00:02:07,880
这样我就能调用它的 dispatch() 方法了

42
00:02:08,960 --> 00:02:13,160
我需要对其它的容器组件做相似地改变

43
00:02:13,380 --> 00:02:14,280
在这种情况下

44
00:02:14,280 --> 00:02:16,280
这个 AddTodo 组件

45
00:02:16,280 --> 00:02:19,060
实际并不是一个真正的容器组件

46
00:02:19,060 --> 00:02:22,480
但它仍然需要 store 来分发 ADD_TODO 动作

47
00:02:22,480 --> 00:02:24,480
所以我添加它作为属性

48
00:02:24,680 --> 00:02:29,460
而且我也为 Footer 组件添加 store 属性

49
00:02:29,460 --> 00:02:31,900
因为很不幸   FilterLink 需要它

50
00:02:31,900 --> 00:02:34,700
Footer 组件渲染 FilterLink 组件

51
00:02:34,700 --> 00:02:36,700
这并不方便

52
00:02:36,700 --> 00:02:37,640
但正如我之前所说的

53
00:02:37,640 --> 00:02:40,820
我们之后会找个办法来解决这个问题

54
00:02:40,820 --> 00:02:43,660
但是现在我们需要往下传递 store

55
00:02:43,660 --> 00:02:46,920
这样每一个容器组件   比如 FilterLink

56
00:02:46,920 --> 00:02:49,540
就能在不依赖顶层变量的情况下

57
00:02:49,540 --> 00:02:52,280
使用它来订阅变化

58
00:02:52,280 --> 00:02:56,180
读取状态和分发动作

59
00:02:56,940 --> 00:03:00,560
我改变 render() 方法为从属性中读取 store

60
00:03:00,560 --> 00:03:01,420
而且现在

61
00:03:01,420 --> 00:03:05,200
所有的容器都从属性中读取 store 实例

62
00:03:05,420 --> 00:03:09,120
不再依赖我之前移除的顶层变量

63
00:03:09,400 --> 00:03:15,560
注意这个变化并没有改变这个应用的行为或数据流

64
00:03:16,200 --> 00:03:19,360
这些容器组件订阅到 store

65
00:03:19,360 --> 00:03:20,780
和之前一样

66
00:03:20,780 --> 00:03:23,820
随着它的变化而更新它们自己的状态

67
00:03:23,820 --> 00:03:28,400
然而   这改变的只是他们访问 store 的方式

68
00:03:28,840 --> 00:03:32,140
之前   它们访问一个顶层变量

69
00:03:32,140 --> 00:03:36,480
但这种方法不能扩展到真实世界的应用

70
00:03:36,480 --> 00:03:38,480
这就是为什么现在

71
00:03:38,480 --> 00:03:41,180
我把 store 作为属性向下传递

72
00:03:41,180 --> 00:03:44,040
这样一来容器组件就能订阅它

73
00:03:44,860 --> 00:03:45,980
在将来的课程中

74
00:03:45,980 --> 00:03:51,500
我们将看到在不需要顶层变量的情况下

75
00:03:51,500 --> 00:03:54,420
如何隐式地向下传递 store 组容器组件

