1
00:00:00,000 --> 00:00:02,240
就像在前两节课一样

2
00:00:02,240 --> 00:00:05,680
我使用 expect 库来进行测试断言

3
00:00:05,800 --> 00:00:10,300
还有 deep-freeze 库来避免我的代码对对象作出意外的修改

4
00:00:10,700 --> 00:00:11,520
在这节课中

5
00:00:11,520 --> 00:00:14,900
我会为一个 todo 列表应用创造一个 reducer

6
00:00:14,980 --> 00:00:18,020
我们会用一个 todo 的数组来描述这个应用的状态

7
00:00:18,680 --> 00:00:22,860
提醒一下   reducer 就是一个纯函数

8
00:00:22,860 --> 00:00:26,860
用来实现应用的更新逻辑

9
00:00:27,020 --> 00:00:30,860
也就是给定当前状态和被分发的动作

10
00:00:30,860 --> 00:00:32,860
如何计算出下一个状态

11
00:00:33,640 --> 00:00:35,420
在开始实现一个 reducer 之前

12
00:00:35,420 --> 00:00:38,400
我希望有一种方式可以知道我的代码是否正确

13
00:00:38,700 --> 00:00:41,740
所以我会先从为 reducer 写测试开始

14
00:00:42,340 --> 00:00:44,220
我现在定义两个变量

15
00:00:44,220 --> 00:00:46,760
一个是 stateBefore  它是一个空数组

16
00:00:46,760 --> 00:00:48,580
另一个是被分发的动作

17
00:00:48,580 --> 00:00:54,740
它描述了用户添加一个新的带有 ID 和内容的 todo

18
00:00:55,460 --> 00:01:00,100
我还声明了在调用 reducer 之后期望得到的状态

19
00:01:00,320 --> 00:01:02,720
就像之前的状态一样 它是一个数组

20
00:01:02,860 --> 00:01:03,660
但不同的是

21
00:01:03,660 --> 00:01:08,120
这一次它会有一个元素代表着刚刚添加的 todo

22
00:01:08,120 --> 00:01:12,300
所以它会有和动作对象一样的 ID 和内容

23
00:01:12,540 --> 00:01:15,760
它还有一个额外的属性叫作  completed

24
00:01:15,880 --> 00:01:18,840
我希望把它初始化为 false

25
00:01:20,080 --> 00:01:23,380
我们希望保证 reducer 是一个纯函数

26
00:01:23,520 --> 00:01:28,080
所以我会对状态和动作调用 deepFreeze()

27
00:01:28,840 --> 00:01:33,280
最后  我已经准备好使用 expect 库来验证

28
00:01:33,320 --> 00:01:38,780
如果我对前一个状态和动作对象调用 todos reducer

29
00:01:38,980 --> 00:01:44,980
那么我得到的结果将会和我刚刚声明的 stateAfter 深层相等

30
00:01:45,720 --> 00:01:47,880
好了  这就是我的第一个测试

31
00:01:47,880 --> 00:01:51,580
现在  我可以像调用一个普通 JavaScript 函数一样调用它

32
00:01:51,740 --> 00:01:54,460
而且  如果它不抛出异常的话

33
00:01:54,560 --> 00:01:58,100
我会看到一个信息  表明测试已经通过

34
00:01:59,680 --> 00:02:01,060
当然  这个测试现在无法通过

35
00:02:01,060 --> 00:02:04,200
因为 reducer 还没有被实现

36
00:02:04,200 --> 00:02:05,780
它是一个空的函数

37
00:02:05,880 --> 00:02:07,680
所以它现在返回 undefined

38
00:02:07,680 --> 00:02:12,740
而不是我所期望的一个带有单一元素的数组

39
00:02:13,680 --> 00:02:14,520
为了修复这个问题

40
00:02:14,520 --> 00:02:18,680
我会需要 reducer 去检查动作的 type 属性

41
00:02:18,680 --> 00:02:19,920
这个属性的值是个字符串

42
00:02:20,280 --> 00:02:22,900
当它匹配 "ADD_TODO" 字符串时

43
00:02:22,900 --> 00:02:25,940
也就是我在测试中指明的动作类型

44
00:02:26,260 --> 00:02:27,940
要满足测试条件

45
00:02:27,940 --> 00:02:30,200
我需要返回一个新的数组

46
00:02:30,280 --> 00:02:33,340
这个数组包含了原有数组的所有元素

47
00:02:33,460 --> 00:02:35,880
还有一个新的 todo 元素

48
00:02:36,020 --> 00:02:40,480
这个元素的 ID 和 text 是从动作对象那里拷贝过来的

49
00:02:40,640 --> 00:02:43,200
同时它的 completed 属性会被设为 false

50
00:02:44,360 --> 00:02:47,840
最后  我给 switch 语句加了一个缺省条件

51
00:02:47,840 --> 00:02:51,500
因为在遇到未知的动作时

52
00:02:51,500 --> 00:02:53,500
每一个 reducer 都需要返回当前的状态

53
00:02:54,740 --> 00:02:56,920
现在测试就通过了

54
00:02:57,340 --> 00:03:00,040
让我们回顾一下这个例子里的数据流

55
00:03:00,040 --> 00:03:01,360
来看一下为什么测试会通过

56
00:03:03,260 --> 00:03:05,620
首先  在我的测试函数里

57
00:03:05,620 --> 00:03:07,100
我创建了一个空的状态数组

58
00:03:07,100 --> 00:03:08,680
还有动作对象

59
00:03:12,020 --> 00:03:16,440
我将它们以参数的形式传递给我的 reducer 函数 todos

60
00:03:17,640 --> 00:03:22,340
接受状态和动作作为参数

61
00:03:22,460 --> 00:03:24,880
然后检查动作的类型

62
00:03:26,200 --> 00:03:30,400
在这个例子中  动作的类型是 "ADD_TODO"

63
00:03:30,720 --> 00:03:34,360
所以它跟 reducer 中的 switch 条件是匹配的

64
00:03:35,540 --> 00:03:37,920
reducer 返回了一个新数组

65
00:03:38,060 --> 00:03:40,640
这个数组包含了原来数组的元素

66
00:03:40,640 --> 00:03:43,960
以及一个代表被添加的 todo 的新元素

67
00:03:44,560 --> 00:03:49,640
不过  测试中我们传进去的状态是个空数组

68
00:03:49,940 --> 00:03:54,120
所以我们会得到一个只有单一元素的数组

69
00:03:54,120 --> 00:03:56,120
而这个元素就是新的 todo

70
00:03:57,260 --> 00:04:02,940
最后  我们将返回值和只有一个 todo 元素的数组对比

71
00:04:03,080 --> 00:04:06,260
确保 reducer 像我们预想的那样运行

72
00:04:06,800 --> 00:04:08,800
这里的等价检查通过了

73
00:04:09,040 --> 00:04:11,440
这样测试就全部通过了

