1
00:00:00,380 --> 00:00:01,160
在这节课

2
00:00:01,160 --> 00:00:04,040
我使用 Expect 库来做一些断言测试

3
00:00:04,180 --> 00:00:08,400
deepFreeze() 方法可以确保我的代码是不会被改变的

4
00:00:08,900 --> 00:00:09,500
比方说

5
00:00:09,500 --> 00:00:13,100
我想要实现一个计数器列表的应用

6
00:00:13,380 --> 00:00:17,060
我需要写一些方法来操作它的状态

7
00:00:17,260 --> 00:00:20,580
而且它的状态是一个 Javascript 数值数组

8
00:00:20,580 --> 00:00:23,000
每一个数值代表一个独立的计数器

9
00:00:23,400 --> 00:00:26,780
第一个方法我想写的是 addCounter()

10
00:00:26,780 --> 00:00:32,120
它需要做的是把一个 0 添加到传递进来的数组末尾

11
00:00:33,300 --> 00:00:34,000
首先

12
00:00:34,000 --> 00:00:36,000
我使用数组的 push() 方法

13
00:00:36,000 --> 00:00:38,640
来添加一个新元素到数组的末尾

14
00:00:38,980 --> 00:00:39,880
工作正常

15
00:00:40,280 --> 00:00:43,740
然而 我们需要学会在 Redux 中避免变化

16
00:00:43,820 --> 00:00:48,400
现在我使用 deepFreeze() 方法强制原来的数组不能变化

17
00:00:49,160 --> 00:00:51,580
现在 push() 方法不管用了

18
00:00:51,980 --> 00:00:55,260
它不能添加一个新的属性到一个被冻结的对象上

19
00:00:55,900 --> 00:00:59,000
为了替代 push()  我将使用 concat() 方法

20
00:00:59,160 --> 00:01:02,140
它不会修改原来的数组

21
00:01:03,080 --> 00:01:05,660
现在在没有改变原有数组的情况下通过了测试

22
00:01:05,780 --> 00:01:12,600
而且我可以使用 ES6 的数组展开运算符来简化代码

23
00:01:14,980 --> 00:01:17,580
我的下一个方法叫 removeCounter()

24
00:01:17,580 --> 00:01:19,580
它接受两个参数

25
00:01:19,660 --> 00:01:21,180
一个是数值数组

26
00:01:21,180 --> 00:01:24,600
一个是需要从数组中移除的那个数值的索引

27
00:01:24,720 --> 00:01:27,080
所以如果我有 3 个数值

28
00:01:27,160 --> 00:01:29,860
同时我传递 1 作为第二个参数

29
00:01:29,860 --> 00:01:32,580
我期望得到一个只有 2 个数值的数组

30
00:01:32,580 --> 00:01:35,540
原来数组中第二个值被跳过了

31
00:01:36,420 --> 00:01:37,040
通常情况下

32
00:01:37,040 --> 00:01:38,820
从数组中删除一个元素

33
00:01:38,820 --> 00:01:40,820
我会使用 splice() 方法

34
00:01:41,200 --> 00:01:43,960
但是  splice() 是一个会改变原有数组的方法

35
00:01:43,960 --> 00:01:46,220
所以你不能在 Redux 中使用它

36
00:01:46,800 --> 00:01:49,240
我会使用 deepFreeze() 来“冻结”数组对象

37
00:01:49,460 --> 00:01:53,860
现在我需要找到另一个办法来从数组中移除一个元素

38
00:01:53,860 --> 00:01:55,280
同时又不修改它

39
00:01:56,160 --> 00:01:58,740
我在这里使用一个叫 slice() 的方法

40
00:01:58,740 --> 00:02:01,880
它跟 splice() 没有任何关系

41
00:02:02,000 --> 00:02:03,280
它不会改变 ( 原来的数组 )

42
00:02:03,440 --> 00:02:06,020
它返回数组中从某个开始的索引

43
00:02:06,060 --> 00:02:08,480
到某个结束的索引之间的那部分

44
00:02:08,540 --> 00:02:10,200
所以我现在正在做的就是

45
00:02:10,200 --> 00:02:14,380
拿到在我想要跳过的索引之前的那部分

46
00:02:14,380 --> 00:02:16,380
和在我想要跳过的索引之后的那部分

47
00:02:16,460 --> 00:02:19,100
然后把它们拼接在一起 从而得到一个新的数组

48
00:02:20,880 --> 00:02:25,200
最后 为了避免使用 concat() 进行链式方法调用

49
00:02:25,300 --> 00:02:30,380
我可以使用 ES6 的数组展开运算符来简化

50
00:02:33,140 --> 00:02:36,600
我们已经实现了添加和删除计数器的功能

51
00:02:36,600 --> 00:02:39,540
现在让我们来实现让计数器递增的功能

52
00:02:39,980 --> 00:02:41,840
incrementCounter() 方法

53
00:02:41,840 --> 00:02:47,880
接收一个数组和数组中计数值要递增的计数器的索引作为参数

54
00:02:48,180 --> 00:02:51,640
返回值是具有相同元素个数的数组

55
00:02:51,720 --> 00:02:53,780
但其中有一个元素被递增了

56
00:02:54,780 --> 00:02:58,160
直接设置数组中对应索引的值是可行的

57
00:02:58,160 --> 00:03:00,160
但这会对原有数组作出改动

58
00:03:00,160 --> 00:03:02,280
所以如果我们增加一个 deepFreeze() 调用

59
00:03:02,280 --> 00:03:04,280
这种做法就不行了

60
00:03:04,980 --> 00:03:09,680
那么我们要怎样替换数组中的一个值同时又不修改它呢？

61
00:03:10,420 --> 00:03:14,560
实际上 这个问题的答案和从数组中移除一个元素类似

62
00:03:15,320 --> 00:03:17,940
我们想拿到索引之前的那部分

63
00:03:17,940 --> 00:03:21,660
拼接一个新值的元素

64
00:03:21,740 --> 00:03:25,040
然后再拼接原来数组中剩下的那部分

65
00:03:25,740 --> 00:03:28,240
最后 通过 ES6 的展开操作符

66
00:03:28,240 --> 00:03:30,900
我们可以展开数组的左边部分

67
00:03:30,900 --> 00:03:32,780
再指定一个新元素

68
00:03:32,780 --> 00:03:35,900
然后展开数数组的右边部分

69
00:03:35,900 --> 00:03:37,520
这样看上去就好多了

70
00:03:38,300 --> 00:03:39,740
这节课你学到了

71
00:03:39,740 --> 00:03:44,800
如何使用 concat() 方法或是展开运算符和 slice() 方法

72
00:03:44,800 --> 00:03:49,220
去添加，移除，修改数组中的元素同时不改变原有数组

73
00:03:49,320 --> 00:03:50,900
以及如何在你的测试中

74
00:03:50,900 --> 00:03:54,120
使用 deepFreeze() 来避免自己被改变

