1
00:00:00,000 --> 00:00:01,480
在上一节课

2
00:00:01,480 --> 00:00:07,060
我从 TodoApp 组件中抽取了 Todo 和 TodoList 组件

3
00:00:07,500 --> 00:00:08,300
在这节课里

4
00:00:08,300 --> 00:00:11,880
我将继续抽取其他展示组件

5
00:00:11,880 --> 00:00:14,500
以此来分离部件的呈现方式和行为

6
00:00:15,680 --> 00:00:22,320
现在我想要把输入框和按钮抽取到一个叫 AddTodo 的组件

7
00:00:23,660 --> 00:00:28,620
我把 AddTodo 声明为一个不接收任何属性的功能组件

8
00:00:29,220 --> 00:00:33,220
然后我会返回这些复制粘贴的输入框和按钮的代码

9
00:00:33,220 --> 00:00:34,980
不过我要把他们放到一个 div 标签里面

10
00:00:34,980 --> 00:00:38,420
因为组件必须有个单独的根元素

11
00:00:39,020 --> 00:00:41,840
功能组件没有实例

12
00:00:42,020 --> 00:00:42,780
尽管如此

13
00:00:42,780 --> 00:00:47,100
我可以使用一个叫 input 的本地变量来代替 this.input

14
00:00:47,400 --> 00:00:49,080
我要把它放在这里

15
00:00:49,100 --> 00:00:51,440
这样我既可以在回调函数中对它进行写入操作

16
00:00:51,640 --> 00:00:54,300
也可以在事件处理器中读取它

17
00:00:54,640 --> 00:00:58,440
像之前一样   我希望它成为一个展示组件

18
00:00:58,440 --> 00:01:00,180
这样就不用声明具体的行为

19
00:01:00,180 --> 00:01:03,080
所以我只是调用名叫 onAddClick() 函数

20
00:01:03,080 --> 00:01:05,080
并对其传入当前的 input.value

21
00:01:05,080 --> 00:01:07,080
我将 onAddClick 变成一个属性

22
00:01:07,080 --> 00:01:09,640
这样使用 AddTodo 的其他部件就可以通过设置 onddClick 属性

23
00:01:09,740 --> 00:01:13,180
来定义按钮被点击后的 AddTodo 行为了

24
00:01:13,720 --> 00:01:14,140
同样的

25
00:01:14,140 --> 00:01:18,660
TodoApp 组件成为了 AddTodo 组件的容器组件

26
00:01:18,900 --> 00:01:22,080
并且它指定了当添加按钮被点击时

27
00:01:22,080 --> 00:01:25,720
AddTodo 会分发一个类型为“ADD_TODO”的动作

28
00:01:25,980 --> 00:01:30,960
动作中还包含有对应的 text 和 nextTodoId 字段信息

29
00:01:31,520 --> 00:01:35,080
我今天想要抽取的最后一个组件是 Footer

30
00:01:35,080 --> 00:01:38,300
它包含了这三个 FilterLink 

31
00:01:41,200 --> 00:01:44,600
我现在要创建一个新的功能组件叫 Footer

32
00:01:44,820 --> 00:01:48,120
我不确定它需要哪些属性   所以我先选择跳过

33
00:01:48,680 --> 00:01:50,660
然后我把整段代码粘贴了过来

34
00:01:51,860 --> 00:01:55,440
看起来 FilterLink 好像需要 visibilityFilter

35
00:01:55,600 --> 00:01:57,440
所以我把它作为一个属性添加上去

36
00:01:57,840 --> 00:02:02,900
我想要让 Footer 和 FilterLink 成为显示组件

37
00:02:02,900 --> 00:02:07,080
但是  FilterLink 现在包含了一个 store.dispatch() 的调用

38
00:02:07,520 --> 00:02:10,780
我会用一个onClick() 调用来代替它

39
00:02:10,780 --> 00:02:14,040
为了调用 FilterLink 的组件的方便

40
00:02:14,040 --> 00:02:16,240
我把 fliter 作为一个单独的参数传递给它

41
00:02:17,260 --> 00:02:19,180
我添加了 onClick() 到 FilterLink 的属性里

42
00:02:19,180 --> 00:02:22,680
现在每一次使用 FilterLinks 时  我都需要声明它

43
00:02:23,080 --> 00:02:26,200
所以我在 Footer 中添加 onFilterClick

44
00:02:26,360 --> 00:02:29,980
然后我为 Footer 中的每个 FilterLink 的 onClick 属性传递了

45
00:02:30,300 --> 00:02:32,520
与 onFilterClick 属性相同的值

46
00:02:32,880 --> 00:02:36,760
所以不管我们传递什么给 Footer 的 onFilterClick 属性

47
00:02:36,760 --> 00:02:42,160
它最终都会成为 FilterLink 中 onClick 属性的值

48
00:02:42,480 --> 00:02:47,460
现在我可以在 TodoApp 部件中使用我刚刚定义的 Footer 组件了

49
00:02:47,700 --> 00:02:49,860
我需要传递一些值给属性

50
00:02:49,860 --> 00:02:52,060
其中一个是 visibilityFilter

51
00:02:52,060 --> 00:02:54,260
这样它就可以高亮活跃的链接

52
00:02:54,260 --> 00:02:57,220
另外一个是属性 onFilterClick 

53
00:02:57,480 --> 00:03:00,680
当一个过滤器标签被点击时

54
00:03:00,680 --> 00:03:05,120
我希望分发一个类型为“SET_VISIBILITY_FILTER”的动作

55
00:03:05,280 --> 00:03:07,640
动作还包含被点击的过滤标签的信息

56
00:03:07,760 --> 00:03:12,500
最后   我注意到 TodoApp 组件没有必要是一个类

57
00:03:12,500 --> 00:03:14,900
我可以将其转换成一个函数

58
00:03:14,960 --> 00:03:18,240
我一般都会尽可能这样做

59
00:03:18,320 --> 00:03:21,840
之前我们是在 render 函数中解构属性

60
00:03:21,840 --> 00:03:25,420
而现在我要在参数里面去解构

61
00:03:26,000 --> 00:03:28,200
我把解构从 render() 中移除掉

62
00:03:28,200 --> 00:03:32,360
同时我还要移除掉 render() 方法的声明

63
00:03:32,360 --> 00:03:35,900
visibleTodos 只在一个地方被使用

64
00:03:35,900 --> 00:03:38,720
所以我把 getVisibleTodos() 调用

65
00:03:38,720 --> 00:03:42,460
移动到 TodoList 的 todos 属性声明里面

66
00:03:42,460 --> 00:03:46,140
现在   我的函数体就只是一个单独的表达式了

67
00:03:46,140 --> 00:03:50,540
所以我可以删除掉返回语句和不必要的代码

68
00:03:50,540 --> 00:03:52,540
这样让代码看起来更简洁

69
00:03:56,040 --> 00:04:00,200
这就是 todo 列表应用的初步重构

70
00:04:00,200 --> 00:04:03,720
我们把应用转化成一个单一的 TodoApp 容器部件

71
00:04:03,720 --> 00:04:08,700
以及多个只关注内容呈现方式的展示部件

72
00:04:10,260 --> 00:04:13,300
让我们回顾一下这个示例中的数据流

73
00:04:14,520 --> 00:04:17,900
我们有一个单独的容器组件叫 TodoApp

74
00:04:17,960 --> 00:04:21,500
并且我们会在每次store改变时重新渲染它

75
00:04:22,240 --> 00:04:26,400
它接收全局的 state 对象的键作为属性

76
00:04:26,400 --> 00:04:30,420
所以它接收了 todos 和  visibilityFilter

77
00:04:31,260 --> 00:04:35,460
它渲染的第一个组件叫 AddTodo

78
00:04:35,860 --> 00:04:38,760
AddTodo 是一个展示组件

79
00:04:38,760 --> 00:04:41,560
渲染了一个输入框和一个按钮

80
00:04:41,560 --> 00:04:43,140
当按钮被点击时

81
00:04:43,140 --> 00:04:47,500
它将当前的输入框的文本传递给 onAddClick() 函数

82
00:04:48,420 --> 00:04:52,760
OnAddClick() 函数是 AddTodo 组件的一个属性

83
00:04:53,700 --> 00:04:56,760
在这个例子中   它是由 TodoApp 所定义的

84
00:04:56,760 --> 00:04:59,360
当按钮被点击时

85
00:04:59,360 --> 00:05:01,060
它应该分发一个动作

86
00:05:01,060 --> 00:05:04,640
其中包含了当前的输入文本

87
00:05:04,880 --> 00:05:08,400
分发”ADD_TODO”动作回调用 reducer

88
00:05:08,400 --> 00:05:11,280
用新的 todo 的数组来更新 store 状态

89
00:05:11,280 --> 00:05:14,820
然后重新渲染 TodoApp 部件

90
00:05:16,020 --> 00:05:20,380
这些 todo 被展示组件 TodoList 渲染

91
00:05:20,380 --> 00:05:22,060
它接受两个属性

92
00:05:22,060 --> 00:05:24,060
一个是当前可见的那些 todo

93
00:05:24,060 --> 00:05:26,740
另一个是 onTodoClick() 回调

94
00:05:31,420 --> 00:05:34,760
TodoList 组件接收一个 todo 的数组

95
00:05:34,840 --> 00:05:36,180
然后通过数组的 map() 方法

96
00:05:36,180 --> 00:05:38,560
来分别渲染每一个 Todo 组件

97
00:05:38,560 --> 00:05:40,600
它使用展开操作符

98
00:05:40,600 --> 00:05:43,340
来将 todo 对象的每个属性

99
00:05:43,340 --> 00:05:45,340
转化成 Todo 部件的属性来传递

100
00:05:45,440 --> 00:05:48,040
它还定义了 onClick 处理器

101
00:05:48,040 --> 00:05:52,820
让它用具体 todo 的 ID 来调用 onTodoClick()

102
00:05:55,140 --> 00:05:57,420
我们之前已经定义了 Todo 组件

103
00:05:57,580 --> 00:06:02,260
它也是一个展示组件   所以它不指定行为

104
00:06:03,460 --> 00:06:05,980
当一个列表项被点击时

105
00:06:05,980 --> 00:06:07,980
它应该调用 onClick 处理器

106
00:06:08,360 --> 00:06:10,620
作为一个展示组件

107
00:06:10,620 --> 00:06:14,460
它表明了在不同条件下部件的呈现方式

108
00:06:14,460 --> 00:06:15,420
在这个例子中

109
00:06:15,420 --> 00:06:20,980
使用了 completed 属性来选择列表项的两种风格中的一种

110
00:06:21,440 --> 00:06:24,020
TodoList 也是一个展示组件

111
00:06:24,020 --> 00:06:28,580
所以它将点击的处理交给了 onTodoClick 

112
00:06:28,580 --> 00:06:32,080
并传递给它了被点击的 todo 的 ID

113
00:06:33,080 --> 00:06:36,200
最后  TodoApp 组件做出反应

114
00:06:36,200 --> 00:06:42,440
分发了一个包含 todo ID 以及类型为”TOGGLE_TODO”的动作

115
00:06:43,880 --> 00:06:48,780
store 会调用我们的 reducer 来更新应用的状态

116
00:06:48,780 --> 00:06:52,160
用新的 todos 重新渲染 TodoApp 组件

117
00:06:53,580 --> 00:06:58,020
Footer 组件接收当前可见的过滤器作为一个属性

118
00:06:58,020 --> 00:07:04,020
以及用来设置当前可见过滤器的 onFilterClick() 回调

119
00:07:05,120 --> 00:07:08,280
Footer 部件渲染了三个 FilterLink

120
00:07:08,280 --> 00:07:12,440
并传递给它们了各自的过滤器值、onClick 处理器

121
00:07:12,440 --> 00:07:14,820
以及当前可见的过滤器

122
00:07:16,000 --> 00:07:19,540
FilterLink 组件作为一个展示型组件

123
00:07:19,540 --> 00:07:21,540
并不知道当它被点击时该做什么

124
00:07:21,640 --> 00:07:23,780
所以它调用 onClick()

125
00:07:23,780 --> 00:07:25,840
将过滤器传递给它作为参数

126
00:07:25,920 --> 00:07:28,300
而每个链接对应的过滤器都是不一样的

127
00:07:29,180 --> 00:07:32,880
Footer 将 FilterLink 的点击处理

128
00:07:32,880 --> 00:07:35,860
代理给 Footer 自己的 onFilterClick 属性

129
00:07:37,040 --> 00:07:43,900
最后  容器组件 TodoApp 在我们的应用中指定了行为

130
00:07:44,000 --> 00:07:47,680
在我们的例子中   这个行为就是   当 FilterLink 被点击时

131
00:07:47,680 --> 00:07:49,600
它应该分发一个动作

132
00:07:49,600 --> 00:07:53,020
动作的类型是”SET_VISIBILITY_FILTER”  并且包含了新的过滤器

133
00:07:53,860 --> 00:07:58,620
在 Redux 中   展示组件的分离并不是强制的

134
00:07:58,620 --> 00:08:00,300
但我推荐这种模式

135
00:08:00,300 --> 00:08:04,020
因为它将渲染从 Redux 中解耦

136
00:08:04,020 --> 00:08:08,040
所以  如果你以后选择将你的工程迁移到另外一个框架

137
00:08:08,040 --> 00:08:08,960
比如 Relay

138
00:08:08,960 --> 00:08:11,880
你就不用修改你全部的组件

139
00:08:11,880 --> 00:08:16,020
因为你的展示组件可以保持原样

140
00:08:16,720 --> 00:08:18,860
这种方法也有缺点

141
00:08:18,860 --> 00:08:22,800
比如你不得不把很多属性   包括回调函数

142
00:08:22,800 --> 00:08:26,960
一层层传给底层组件

143
00:08:27,600 --> 00:08:33,280
这个问题可以通过引入多个中间容器组件来轻松解决

144
00:08:33,280 --> 00:08:35,280
而我们将在下一课中学习这个方法

