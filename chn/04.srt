1
00:00:00,000 --> 00:00:09,460
你大概已经听说过了 当使用纯函数来描述应用的状态数据信息时 视图层信息是可预测的

2
00:00:10,020 --> 00:00:12,360
这一方法最先被 React 所提出

3
00:00:12,360 --> 00:00:17,020
如今其他框架也都逐渐开始学习使用这一思想 例如 Ember 和 Angular

4
00:00:17,020 --> 00:00:21,100
Redux 通过使用其他思想完善了这一方法

5
00:00:21,100 --> 00:00:26,940
应用中的状态变化使用纯函数来进行描述

6
00:00:26,940 --> 00:00:31,120
函数中传入之前的状态信息和发出的 action 动作信息

7
00:00:31,120 --> 00:00:35,220
然后返回应用下一状态的信息

8
00:00:36,080 --> 00:00:40,980
在任何一个 Redux 应用中都存在这么一个特殊的函数

9
00:00:40,980 --> 00:00:46,000
它以整个应用的状态和分发的状态信息为参数

10
00:00:46,000 --> 00:00:49,680
返回应用的下一个状态

11
00:00:49,680 --> 00:00:54,040
最重要的一点是 它没有更改传入的状态信息

12
00:00:54,040 --> 00:00:58,400
因为是纯函数 所以会重新返回一个新的状态对象

13
00:00:59,400 --> 00:01:01,800
甚至在大型应用中 

14
00:01:01,800 --> 00:01:13,350
这种基于当前状态和触发的 action 动作并返回新的状态信息的函数也只有一个

15
00:01:14,350 --> 00:01:15,420
但是这并不会影响程序的效率

16
00:01:15,960 --> 00:01:19,060
例如 如果我更改了可视状态信息

17
00:01:19,060 --> 00:01:22,300
我需要创建一个新的状态对象

18
00:01:22,300 --> 00:01:27,480
但是我依然可以引用之前的待办事项信息

19
00:01:27,480 --> 00:01:31,600
因为在我更改可视状态信息时它并没有被改变

20
00:01:31,600 --> 00:01:34,820
这就是 Redux 速度快的原因

21
00:01:34,820 --> 00:01:38,520
现在你应该知道 Redux 的第三个原则是什么了吧

22
00:01:38,520 --> 00:01:42,120
为了描述状态信息变化 你需要创建一个函数

23
00:01:42,120 --> 00:01:45,840
获取应用前状态和触发的 action 动作

24
00:01:45,840 --> 00:01:48,360
然后函数会返回新的应用状态信息

25
00:01:48,360 --> 00:01:53,600
该函数方法是个纯函数 我们称它为 Reducer

