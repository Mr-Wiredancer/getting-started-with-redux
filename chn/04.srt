1
00:00:00,000 --> 00:00:09,460
你大概已经听说过了，当使用纯函数来描述应用的状态数据信息时，视图层信息是可预测的

2
00:00:10,020 --> 00:00:12,360
这一方法最先被React所提出

3
00:00:12,360 --> 00:00:17,020
如今其他框架也都逐渐开始学习使用这一思想，例如Ember和Angular。

4
00:00:17,020 --> 00:00:21,100
Redux 通过使用其他思想完善了这一方法

5
00:00:21,100 --> 00:00:26,940
应用中的状态变化使用纯函数来进行描述

6
00:00:26,940 --> 00:00:31,120
函数中传入之前的状态信息和发出的action动作信息

7
00:00:31,120 --> 00:00:35,220
然后返回应用下一状态的信息

8
00:00:36,080 --> 00:00:40,980
在任何一个Redux应用中都存在这么一个特殊的函数

9
00:00:40,980 --> 00:00:44,000
它会获取整个应用的状态信息

10
00:00:44,000 --> 00:00:46,000
在action动作被触发时

11
00:00:46,000 --> 00:00:49,680
该函数会返回新的应用状态信息

12
00:00:49,680 --> 00:00:54,040
最重要的一点是，它没有更改传入的状态信息

13
00:00:54,040 --> 00:00:58,400
因为是纯函数，所以会重新返回一个新的状态对象

14
00:00:59,400 --> 00:01:04,240
甚至在大型应用中也只需要单个函数

15
00:01:04,240 --> 00:01:13,420
就能基于前状态和触发的action动作快速计算返回新的状态信息

16
00:01:15,960 --> 00:01:19,060
例如，如果我更改了可视状态信息

17
00:01:19,060 --> 00:01:22,300
我需要创建一个新的状态对象

18
00:01:22,300 --> 00:01:27,480
但是我依然可以引用之前的待办事项信息

19
00:01:27,480 --> 00:01:31,600
因为在我更改可视状态信息时它并没有被改变

20
00:01:31,600 --> 00:01:34,820
这就是Redux速度快的原因

21
00:01:34,820 --> 00:01:38,520
现在你应该知道Redux的第三个原则是什么了吧

22
00:01:38,520 --> 00:01:42,120
为了描述状态信息变化，你需要创建一个函数

23
00:01:42,120 --> 00:01:45,840
获取应用前状态和触发的action动作

24
00:01:45,840 --> 00:01:48,360
然后函数会返回新的应用状态信息

25
00:01:48,360 --> 00:01:53,600
该函数方法是个纯函数，我们称它为---Reducer

