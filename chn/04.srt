1
00:00:00,520 --> 00:00:01,600
你大概已经听说过了

2
00:00:01,740 --> 00:00:06,700
 当被描述成一个应用的状态的纯函数时 

3
00:00:06,700 --> 00:00:09,240
 UI 或者视图层是最为明确的

4
00:00:10,020 --> 00:00:12,360
这一方法最先被 React 所提出

5
00:00:12,360 --> 00:00:17,020
如今其他框架像 Ember 和 Angular 也都逐渐开始学习这一方法

6
00:00:17,500 --> 00:00:20,880
Redux 则通过另一个点子完善了这一方法

7
00:00:21,100 --> 00:00:26,940
那就是 应用中的状态变化需要被描述成一个纯函数

8
00:00:26,940 --> 00:00:31,120
这个函数会接受前一个状态和被分发动作

9
00:00:31,120 --> 00:00:35,220
然后返回应用的下一个状态

10
00:00:36,080 --> 00:00:40,980
在任何一个 Redux 应用中都存在这么一个特定的函数

11
00:00:40,980 --> 00:00:45,860
它以整个应用的状态和被分发的动作为参数

12
00:00:46,000 --> 00:00:49,680
返回应用的下一个状态

13
00:00:49,680 --> 00:00:54,040
很重重要的一点是 它没有更改传入的状态

14
00:00:54,040 --> 00:00:58,400
它必须得是纯函数 所以它必然会返回一个新的状态

15
00:00:59,500 --> 00:01:01,700
即使在大型应用中

16
00:01:01,940 --> 00:01:04,100
这样的函数也只有一个

17
00:01:04,460 --> 00:01:11,460
这个函数描述了 如何根据应用的上一个状态和被分发的动作

18
00:01:11,460 --> 00:01:13,460
计算出下一个状态

19
00:01:14,200 --> 00:01:15,780
这个函数并不一定会影响性能

20
00:01:15,960 --> 00:01:19,060
比如 如果我更改了过滤器标签

21
00:01:19,060 --> 00:01:22,300
我需要为整个应用的状态创建一个新的对象

22
00:01:22,300 --> 00:01:27,480
但是我仍然可以保留对之前 todos 数组的引用

23
00:01:27,480 --> 00:01:31,600
因为在我更改过滤器标签时 这个数组并没有被改变

24
00:01:31,600 --> 00:01:34,820
这就是 Redux 性能很好的原因

25
00:01:34,820 --> 00:01:38,520
现在你已经了解了 Redux 的第三个原则

26
00:01:38,860 --> 00:01:41,960
为了描述状态的变化 你需要创建一个函数

27
00:01:42,220 --> 00:01:45,840
它接受应用的上一个状态和被分发的动作

28
00:01:45,840 --> 00:01:48,360
然后返回应用的下一个状态

29
00:01:48,360 --> 00:01:50,460
而这个函数必须是一个纯函数

30
00:01:51,000 --> 00:01:53,520
它被称作 reducer
