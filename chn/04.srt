1
00:00:00,520 --> 00:00:01,600
你大概已经听说过了

2
00:00:01,740 --> 00:00:06,700
当被描述成一个应用的状态的纯函数时

3
00:00:06,700 --> 00:00:09,240
UI 或者视图层是最为明确的

4
00:00:10,020 --> 00:00:12,360
这一方法最先被 React 所提出

5
00:00:12,360 --> 00:00:14,440
如今其他框架也都逐渐开始学习这一方法

6
00:00:14,440 --> 00:00:16,300
例如 Ember 和 Angular 

7
00:00:17,500 --> 00:00:20,880
Redux 则通过另一个点子完善了这一方法

8
00:00:21,100 --> 00:00:24,200
那就是 应用中的状态变化

9
00:00:24,280 --> 00:00:26,940
需要被描述成一个纯函数

10
00:00:26,940 --> 00:00:31,120
这个函数会接受前一个状态和被分发动作

11
00:00:31,120 --> 00:00:35,220
然后返回应用的下一个状态

12
00:00:36,080 --> 00:00:38,820
在任何一个 Redux 应用中

13
00:00:38,820 --> 00:00:40,980
都存在这么一个特定的函数
在任何一个 Redux 应用中

14
00:00:40,980 --> 00:00:45,860
它以整个应用的状态和被分发的动作为参数

15
00:00:46,000 --> 00:00:49,680
返回应用的下一个状态

16
00:00:49,680 --> 00:00:54,040
很重重要的一点是 它没有更改传入的状态

17
00:00:54,040 --> 00:00:55,340
它必须得是纯函数

18
00:00:58,400 --> 00:00:59,500
所以它必然会返回一个新的状态

19
00:00:59,500 --> 00:01:01,700
即使在大型应用中

20
00:01:01,940 --> 00:01:04,100
这样的函数也只有一个

21
00:01:04,460 --> 00:01:05,420
这个函数描述 

22
00:01:11,380 --> 00:01:11,460
如何根据应用的上一个状态和被分发的动作

23
00:01:11,460 --> 00:01:13,460
计算出下一个状态

24
00:01:14,200 --> 00:01:15,780
这个函数并不一定会影响性能

25
00:01:15,960 --> 00:01:19,060
比如 如果我更改了过滤器标签

26
00:01:19,060 --> 00:01:22,300
我需要为整个应用的状态创建一个新的对象

27
00:01:22,300 --> 00:01:27,480
但是我仍然可以保留对之前 todos 数组的引用

28
00:01:27,480 --> 00:01:29,220
因为在我更改过滤器标签时

29
00:01:29,220 --> 00:01:31,440
 这个数组并没有被改变
因为在我更改过滤器标签时

30
00:01:31,440 --> 00:01:31,600
因为在我更改过滤器标签时

31
00:01:31,600 --> 00:01:34,820
这就是 Redux 性能很好的原因

32
00:01:34,820 --> 00:01:38,520
现在你已经了解了 Redux 的第三个原则

33
00:01:38,860 --> 00:01:40,540
为了描述状态的变化 

34
00:01:40,540 --> 00:01:40,560
你需要创建一个函数
为了描述状态的变化 

35
00:01:40,560 --> 00:01:42,060
你需要创建一个函数

36
00:01:42,220 --> 00:01:45,840
它接受应用的上一个状态和被分发的动作

37
00:01:45,840 --> 00:01:48,360
然后返回应用的下一个状态

38
00:01:48,360 --> 00:01:50,460
而这个函数必须是一个纯函数

39
00:01:51,000 --> 00:01:53,520
它被称作 reducer

