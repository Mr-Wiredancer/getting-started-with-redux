1
00:00:00,220 --> 00:00:01,300
在上一课中

2
00:00:01,300 --> 00:00:04,220
我们学习了使用 Redux 中的 combineReducers() 函数

3
00:00:04,220 --> 00:00:10,000
这个函数可以将多个 reducer 合并成一个 reducer

4
00:00:10,050 --> 00:00:13,020
而这些 reducer 分别管理了状态树的不同部分

5
00:00:14,200 --> 00:00:18,900
为了深入理解 combineReducers() 函数

6
00:00:19,200 --> 00:00:22,200
我们会在这节课中从头实现它

7
00:00:24,320 --> 00:00:26,570
combineReducers() 是一个函数

8
00:00:26,600 --> 00:00:29,270
所以我要写一个函数声明

9
00:00:29,300 --> 00:00:34,670
这个函数唯一的参数是状态的键和 reducer 之间的映射关系

10
00:00:34,750 --> 00:00:37,220
所以我把它叫做 reducers

11
00:00:37,770 --> 00:00:41,350
这个函数的返回值本身也应该是一个 reducer

12
00:00:41,520 --> 00:00:44,920
所以这是一个返回另一个函数的函数

13
00:00:45,050 --> 00:00:49,450
而被返回的函数的签名也应该是一个 reducer 函数的签名

14
00:00:49,450 --> 00:00:51,450
也就是一个状态和一个动作

15
00:00:53,420 --> 00:00:56,170
现在，我要调用 Object.keys() 这个方法

16
00:00:56,220 --> 00:01:00,070
它会返回包含 reducers 对象的所有键的数组

17
00:01:00,170 --> 00:01:01,270
在我们的这个例子中

18
00:01:01,270 --> 00:01:04,200
我们得到的是 "todos" 和 "visibilityFilter"

19
00:01:05,420 --> 00:01:09,450
接下来 我根据这些键来调用（数组的） reduce() 方法

20
00:01:09,520 --> 00:01:12,300
因为我想通过遍历每一个 reducer 键来调用对应的 reducer 函数

21
00:01:12,300 --> 00:01:15,250
最后把他们叠加起来

22
00:01:15,250 --> 00:01:19,520
生成一个单一的值作为下一个状态

23
00:01:20,550 --> 00:01:24,100
每个传入 combineReducers() 函数的 reducer

24
00:01:24,220 --> 00:01:28,100
都只负责更新状态树中的某个部分

25
00:01:28,750 --> 00:01:31,420
这就是为什么我说

26
00:01:31,450 --> 00:01:35,350
要计算出某个健的下一个状态

27
00:01:35,350 --> 00:01:38,670
只要用这个健对应的当前状态和动作

28
00:01:38,670 --> 00:01:43,220
调用这个健对应的 reducer 就可以了

29
00:01:46,120 --> 00:01:51,520
这个数组的 reduce() 方法想要我在回调中返回下一个需要叠加的值

30
00:01:51,520 --> 00:01:53,750
所以我在这里返回 nextState

31
00:01:53,950 --> 00:01:56,820
同时我指定了一个空对象作为 nextState 的初始值

32
00:01:56,920 --> 00:02:01,200
它会在任何键被处理之前初始化

33
00:02:02,120 --> 00:02:03,370
现在我们就完成了

34
00:02:03,370 --> 00:02:07,600
这是一个 Redux 的 combineReducer() 函数的重新实现

35
00:02:07,600 --> 00:02:09,320
而且它是可用的

36
00:02:12,020 --> 00:02:14,450
让我们简短地回顾下这是如何实现的

37
00:02:14,650 --> 00:02:17,170
我调用了 combineReducers() 函数 它的参数是对象

38
00:02:17,200 --> 00:02:19,670
这个对象的值是多个 reducer 函数

39
00:02:19,670 --> 00:02:22,170
而它的键则是对应的 reducer 函数所管理的状态字段

40
00:02:23,370 --> 00:02:25,620
在这个函数最后生成的 reducer 中

41
00:02:25,650 --> 00:02:30,650
我提取了所有传入到 combineReducers() 函数的 reducer 的键

42
00:02:30,720 --> 00:02:34,600
也就是 "todos" 和 "visibilityFilter"

43
00:02:36,200 --> 00:02:39,570
我先用一个空对象初始化 nextState

44
00:02:39,620 --> 00:02:42,800
然后用数组的 reduce() 函数来遍历这些键

45
00:02:42,800 --> 00:02:44,620
逐步填充 nextState 对象

46
00:02:45,870 --> 00:02:50,100
注意 我在每一次遍历中都修改了 nextState 对象

47
00:02:50,520 --> 00:02:51,850
这么做并没什么问题

48
00:02:51,850 --> 00:02:55,250
因为这个对象是我在 reducer 中创建的

49
00:02:55,250 --> 00:02:57,850
它不是从外部传入的

50
00:02:57,850 --> 00:03:00,150
所以 reducer 还是一个纯函数

51
00:03:01,650 --> 00:03:04,400
要计算出一个键的下一状态

52
00:03:04,400 --> 00:03:07,320
我们会调用对应的 reducer 函数

53
00:03:07,320 --> 00:03:10,300
比如 todos() 和 visibilityFilter() 函数

54
00:03:12,150 --> 00:03:18,700
我们只会给子 reducer 传递那个键所对应的状态的一部分

55
00:03:19,170 --> 00:03:21,770
所以如果生成的 reducer 的状态是一个单独的对象

56
00:03:21,770 --> 00:03:24,370
它只会传递给键所对应的那部分状态

57
00:03:24,370 --> 00:03:29,120
例如 todos 和 visibilityFilter

58
00:03:29,220 --> 00:03:33,420
然后在 nextState 用同样的键把结果保存下来

59
00:03:34,820 --> 00:03:37,620
最后 我们使用数组的 reduce() 操作

60
00:03:37,620 --> 00:03:41,150
它以一个空对象作为 nextState 的初始值

61
00:03:41,150 --> 00:03:43,950
然后在每一次迭代中填充它

62
00:03:43,950 --> 00:03:48,500
直到它可以作为整个 reduce 操作的结果被返回

63
00:03:50,250 --> 00:03:51,870
这节课中

64
00:03:51,870 --> 00:03:57,720
你学习了如何从头实现 Redux 中的 combineReducers() 工具函数

65
00:03:58,420 --> 00:04:01,120
如果你还没有完全明白它的工作原理

66
00:04:01,120 --> 00:04:02,470
没有关系

67
00:04:02,470 --> 00:04:05,450
因为这对于使用 Redux 并不是非常重要

68
00:04:05,570 --> 00:04:09,670
但是 练习函数式编程

69
00:04:09,850 --> 00:04:14,120
以及理解函数可以接受其它函数为参数

70
00:04:14,120 --> 00:04:16,120
然后返回其它函数

71
00:04:16,120 --> 00:04:17,400
是一个很好的主义

72
00:04:17,400 --> 00:04:19,550
因为长期来说

73
00:04:19,570 --> 00:04:22,550
理解这些会让你在使用 Redux 时更具生产力

