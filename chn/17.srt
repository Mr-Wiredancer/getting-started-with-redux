1
00:00:00,220 --> 00:00:01,350
在前面几课中

2
00:00:01,350 --> 00:00:06,620
我们学习了如何将根 reducer 拆分成多个小 reducer

3
00:00:06,620 --> 00:00:09,250
让这些小的 reducer 来管理状态树的不同部分

4
00:00:09,570 --> 00:00:12,700
而我们现在已经有一个写好的 todoApp reducer

5
00:00:12,700 --> 00:00:16,270
来处理 todo 应用的所有动作

6
00:00:16,600 --> 00:00:19,500
所以现在是时候来实现视图层了

7
00:00:19,500 --> 00:00:22,370
在这个例子中我准备使用 React

8
00:00:24,250 --> 00:00:28,400
我现在添加 react 和 react-dom 这两个库

9
00:00:28,420 --> 00:00:30,270
它们都放在 Facebook CDN 上

10
00:00:30,700 --> 00:00:34,220
同时我还添加了一个 ID 为 "root" 的 div 标签

11
00:00:34,220 --> 00:00:37,670
我准备用它来渲染我的 React 应用

12
00:00:39,100 --> 00:00:43,220
与第八课的 React 计数器示例类似

13
00:00:43,400 --> 00:00:45,900
我声明了一个 render() 函数

14
00:00:45,900 --> 00:00:51,300
用它来根据当前的应用状态更新 DOM

15
00:00:51,420 --> 00:00:57,320
现在我要订阅 store 的变化

16
00:00:57,320 --> 00:01:00,070
在最开始以及每次 store 变化时调用 render() 函数

17
00:01:00,420 --> 00:01:04,320
而 render() 函数的实现会用到 React

18
00:01:04,320 --> 00:01:10,050
所以我会用某个我还没实现的 TodoApp 部件来调用 ReactDom.render()

19
00:01:10,200 --> 00:01:15,450
然后 render() 会把应用渲染到我在 HTML 里面创建的 div 标签

20
00:01:15,450 --> 00:01:18,870
也就是 ID 为 "root" 的 div 标签

21
00:01:20,470 --> 00:01:24,520
React 为所有的部件提供了一个模版类

22
00:01:24,520 --> 00:01:29,100
所以我把这个 React.Component 类从 React 对象里取出来

23
00:01:29,370 --> 00:01:32,800
然后我声明了一个

24
00:01:32,800 --> 00:01:35,520
继承这个 React 模版类的 TodoApp 部件

25
00:01:36,070 --> 00:01:39,570
这个部件只有一个 render() 函数

26
00:01:39,570 --> 00:01:41,700
而且它会返回一个 div 部件

27
00:01:42,000 --> 00:01:43,370
在 div 部件里

28
00:01:43,370 --> 00:01:45,050
我会加上一个 button 部件

29
00:01:45,070 --> 00:01:46,550
上面写着 "Add Todo"

30
00:01:46,850 --> 00:01:50,800
但我还不想加上一个 input 字段

31
00:01:50,800 --> 00:01:52,900
因为我想先让我的示例保持简单一些

32
00:01:53,020 --> 00:01:56,370
所以我现在要分发一个 "ADD_TODO" 动作

33
00:01:56,370 --> 00:02:01,700
用 "Test" 字符串作为它的 text 字段

34
00:02:01,770 --> 00:02:05,350
它会不断地添加内容为 "Test" 的待办事项

35
00:02:05,870 --> 00:02:07,200
对了 还有 ID

36
00:02:07,200 --> 00:02:09,820
我需要声明一个序列化的 ID

37
00:02:09,820 --> 00:02:15,220
这就是为什么我声明了一个全局变量 nextTodoId

38
00:02:15,320 --> 00:02:17,300
然后我现在会不断地让它递增

39
00:02:17,300 --> 00:02:17,320
所以每一次
然后我现在会不断地让它递增

40
00:02:17,320 --> 00:02:19,200
所以每一次

41
00:02:19,200 --> 00:02:21,200
它都会生成一个新的 ID

42
00:02:21,520 --> 00:02:22,950
最后

43
00:02:22,950 --> 00:02:26,770
我还想要显示一个待办事项的列表

44
00:02:26,950 --> 00:02:32,070
假设我把待办事项以 todos 属性来注入

45
00:02:32,270 --> 00:02:35,350
我会调用 map() 函数

46
00:02:35,350 --> 00:02:41,120
让每一个待办事项显示它的内容

47
00:02:41,800 --> 00:02:45,770
最后 因为我需要 todos 作为一个属性

48
00:02:46,200 --> 00:02:49,170
我会读取当前的 store 状态

49
00:02:49,250 --> 00:02:54,200
把它的 todos 字段传递给 TodoApp

50
00:02:55,520 --> 00:02:58,000
你可以看到一个写着 "Add Todo" 的按钮

51
00:02:58,000 --> 00:02:59,250
每一次我点击它

52
00:02:59,250 --> 00:03:00,770
我就会看到一个新的待办事项

53
00:03:00,770 --> 00:03:02,470
上面的内容就是 "Test"

54
00:03:03,650 --> 00:03:07,900
现在我要在 render() 函数里添加一个 input 部件

55
00:03:08,050 --> 00:03:12,320
然后我要使用 React 的 ref API

56
00:03:12,320 --> 00:03:14,250
这里的 ref 是一个函数

57
00:03:14,250 --> 00:03:17,900
它会得到对应的 DOM 节点

58
00:03:17,900 --> 00:03:22,050
然后我要把这个节点存放在 this.input 里

59
00:03:22,170 --> 00:03:26,870
所以我能够在我的事件处理器里读取 input 部件的值

60
00:03:26,870 --> 00:03:30,100
我现在要读取 this.input.value

61
00:03:30,370 --> 00:03:35,270
而且我还可以在分发动作之后重置 this.input.value

62
00:03:35,270 --> 00:03:37,270
这样 input 里面的内容就被清除了

63
00:03:37,970 --> 00:03:40,720
现在如果我在这里填写一些内容

64
00:03:40,720 --> 00:03:42,100
然后点击 "Add Todo" 按钮

65
00:03:42,150 --> 00:03:44,450
那么 "ADD_TODO" 动作就会被分发

66
00:03:44,450 --> 00:03:46,050
然后输入框里面的内容会被清除

67
00:03:47,870 --> 00:03:51,250
让我们花点时间来回顾一下这个应用的工作原理

68
00:03:52,420 --> 00:03:55,370
从 TodoApp 这个 React 部件开始

69
00:03:55,900 --> 00:04:00,170
这个部件并不知道 todos 是如何被添加的

70
00:04:00,370 --> 00:04:04,350
但是它可以通过分发 "ADD_TODO" 动作

71
00:04:04,350 --> 00:04:08,000
来表达它想改变状态的愿望

72
00:04:08,470 --> 00:04:12,000
它使用当前输入框的值作为 todo 的 text 字段

73
00:04:12,000 --> 00:04:17,050
还传入了一个递增的 ID 作为 todo 的 id

74
00:04:17,450 --> 00:04:19,670
每一个 todo 都需要有自己的 ID

75
00:04:19,670 --> 00:04:21,070
而在这个例子里

76
00:04:21,070 --> 00:04:23,070
我们只管递增计数器

77
00:04:23,070 --> 00:04:26,850
所以我们总会得到下一个整数作为 ID

78
00:04:27,620 --> 00:04:29,550
在 Redux 应用中

79
00:04:29,550 --> 00:04:32,000
React 部件分发动作是很常见的

80
00:04:32,000 --> 00:04:33,950
但同样重要的是

81
00:04:33,950 --> 00:04:33,970
React 部件要能够渲染当前的状态
但同样重要的是

82
00:04:33,970 --> 00:04:36,250
React 部件要能够渲染当前的状态

83
00:04:36,750 --> 00:04:41,600
我的 TodoApp 部件会假设自己以属性的方式得到 todos

84
00:04:41,600 --> 00:04:43,870
然后它会遍历所有的 todos

85
00:04:43,870 --> 00:04:45,350
使用 ID 作为 key 属性

86
00:04:45,350 --> 00:04:47,520
以列表的方式来显示它们

87
00:04:48,270 --> 00:04:51,420
在最开始以及每次 store 状态改变的时候

88
00:04:51,420 --> 00:04:56,220
这个部件都会在 render() 函数里被渲染

89
00:04:57,220 --> 00:05:00,550
render() 函数读取 store 的当前状态

90
00:05:00,550 --> 00:05:05,470
然后将从当前状态里得到的 todos 数组

91
00:05:05,470 --> 00:05:08,250
以属性方式传递给 TodoApp 部件

92
00:05:08,900 --> 00:05:12,200
render() 函数在每一次 store 变化都会被调用

93
00:05:12,200 --> 00:05:15,070
所以 todos 属性会一直保持最新版本

94
00:05:16,050 --> 00:05:19,100
这就是 Redux 工作流的渲染部分

95
00:05:19,220 --> 00:05:22,270
让我们回顾一下 Redux 中的变化是怎么运作的

96
00:05:23,120 --> 00:05:28,700
任何的状态变化都是由部件里某处的 sotre.dispatch() 引起的

97
00:05:29,300 --> 00:05:31,100
当一个动作被分发时

98
00:05:31,120 --> 00:05:34,770
store 会用当前状态和被分发的动作

99
00:05:35,020 --> 00:05:38,250
调用与 store 一起被创建的 reducer

100
00:05:38,450 --> 00:05:39,600
而在我们的例子中

101
00:05:39,600 --> 00:05:41,550
它就是 todoApp reducer

102
00:05:41,700 --> 00:05:46,400
它是由 visibilityFilter 和 todos 着两个 reducer 组合而来的

103
00:05:47,370 --> 00:05:50,220
它会将动作的类型和 switch 条件作匹配

104
00:05:50,370 --> 00:05:52,770
如果动作的类型是 "ADD_TODO"

105
00:05:52,900 --> 00:05:56,070
这里的确就是 "ADD_TODO"

106
00:05:56,570 --> 00:05:57,700
在这种情况下

107
00:05:57,700 --> 00:06:01,470
它会调用 todo reducer

108
00:06:01,770 --> 00:06:04,650
将 undefined 和动作传递给它

109
00:06:04,670 --> 00:06:07,820
这里传递 undefined 是因为新的 todo 没有任何状态可以传递

110
00:06:08,100 --> 00:06:10,200
在 todo 这个 reducer 中

111
00:06:10,200 --> 00:06:11,970
我们也有类似的 switch 语句

112
00:06:12,200 --> 00:06:14,370
而这里的动作类型是 "ADD_TODO"

113
00:06:14,370 --> 00:06:17,200
所以它返回了 todo 的初始状态

114
00:06:17,200 --> 00:06:19,750
里面有 ID 和 从动作中获得的的 text

115
00:06:19,750 --> 00:06:22,150
还有设为 false 的 completed 字段

116
00:06:23,100 --> 00:06:27,250
调用 todo 的这个 todos reducer 会返回一个新的数组

117
00:06:27,250 --> 00:06:29,000
包含了所有已有的 todo

118
00:06:29,120 --> 00:06:32,070
而数组的最末端是新添加的 todo

119
00:06:32,220 --> 00:06:35,500
这样就将一个新的  todo 添加到了当前状态

120
00:06:36,470 --> 00:06:41,920
最后 合并起来的 todoApp reducer 会使用这个新的数组

121
00:06:41,920 --> 00:06:46,850
作为全局的状态对象中 todos 字段的值

122
00:06:46,850 --> 00:06:49,870
它会返回一个新的状态对象

123
00:06:49,870 --> 00:06:55,320
其中的 todos 字段对应了那个带有新添加的 todo 项的数组

124
00:06:55,950 --> 00:07:00,200
todoApp reducer 是这个应用的根 reducer

125
00:07:00,200 --> 00:07:02,670
它是与 store 一起被创建的

126
00:07:02,950 --> 00:07:07,070
所以它的下一个状态就是 Redux store 的下一个状态

127
00:07:07,200 --> 00:07:09,870
所有的监听者都会被通知

128
00:07:10,520 --> 00:07:15,900
render() 函数会订阅到 store 的变化

129
00:07:15,900 --> 00:07:19,100
它会通过调用 getState() 来得到新的状态

130
00:07:19,100 --> 00:07:22,350
将最新的 todos 传递给部件

131
00:07:22,350 --> 00:07:25,800
用新的数据来重新渲染

