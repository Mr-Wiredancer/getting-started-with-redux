1
00:00:00,260 --> 00:00:04,740
Redux 的第二原则：状态树 (state tree) 是只读的

2
00:00:04,920 --> 00:00:07,300
你不能修改或者对它进行写入操作

3
00:00:07,720 --> 00:00:10,480
所以 每当你希望改变状态的时候

4
00:00:10,700 --> 00:00:12,900
你需要分发一个动作 (action)

5
00:00:13,900 --> 00:00:17,880
一个动作其实就是一个描述变化的普通 JavaScript 对象

6
00:00:18,400 --> 00:00:23,120
就像状态是应用中的数据的一个最小化抽象

7
00:00:23,380 --> 00:00:28,420
动作就是数据改变的最小化抽象

8
00:00:29,340 --> 00:00:32,160
你可以自己决定动作对象的结构

9
00:00:32,360 --> 00:00:35,640
唯一的要求就是它必须有一个“type”属性

10
00:00:35,780 --> 00:00:37,300
而且这个“type”属性不能够是“undefined”

11
00:00:37,420 --> 00:00:39,060
我们会建议使用字符串

12
00:00:39,200 --> 00:00:40,960
因为字符串是可以序列化的

13
00:00:41,700 --> 00:00:42,860
在不同的应用中

14
00:00:42,880 --> 00:00:45,060
你会需要用到不同类型的动作

15
00:00:45,060 --> 00:00:50,740
比如 在一个计数器里我们只需要“INCREMENT”和“DECREMENT”两个动作

16
00:00:50,860 --> 00:00:53,940
而不需要再传入其它额外的信息

17
00:00:53,940 --> 00:00:57,460
因为这些已经足够描述应用的变化了

18
00:00:58,700 --> 00:01:01,940
但是在这个多计数器的例子里

19
00:01:01,940 --> 00:01:03,340
我们有更多的动作

20
00:01:03,340 --> 00:01:05,340
我们有“ADD_COUNTER”动作

21
00:01:05,760 --> 00:01:07,800
有“REMOVE_COUNTER”动作

22
00:01:08,380 --> 00:01:12,160
而当每一次我改变某个计数器时

23
00:01:12,320 --> 00:01:17,960
你可以看到“INCREMENT”和“DECREMENT”动作附带了“index”这个信息

24
00:01:18,220 --> 00:01:22,780
这是因为我们需要定位 到底是哪一个计数器发生了改变

25
00:01:24,380 --> 00:01:28,720
这个方法可以很好地扩展到中型和更为复杂的应用

26
00:01:29,540 --> 00:01:35,340
每一次我添加一个待办事项 部件本身其实不知道它到底是怎么被添加的

27
00:01:35,600 --> 00:01:39,960
它所知道的只是要分发一个动作 这个动作包含了值为“ADD_TODO”的属性“type”

28
00:01:39,960 --> 00:01:44,580
待办事项的内容 以及一个序列化的 ID

29
00:01:45,220 --> 00:01:50,060
如果我完成／撤销一个待办事项 跟之前的状况一样 组件不会知道它是怎么发生的

30
00:01:50,300 --> 00:01:54,140
它也只会知道需要分发一个动作 这个动作包含了值为“ADD_TODO”的属性“type”

31
00:01:54,140 --> 00:01:59,120
以及传入我想完成／撤销的待办事项的 ID

32
00:01:59,800 --> 00:02:02,420
对于过滤标签的操作也是如此

33
00:02:02,640 --> 00:02:04,960
每一次我点击这些过滤标签

34
00:02:05,080 --> 00:02:07,480
来改变现在可见的待办事项时

35
00:02:07,620 --> 00:02:13,280
这个部件实际上分发了一个动作

36
00:02:13,280 --> 00:02:15,060
这个动作的“type”属性是“SET_VISIBILITY_FILTER”

37
00:02:15,200 --> 00:02:19,480
而“filter”属性则是对应的过滤器类型

38
00:02:19,640 --> 00:02:22,100
但所有的这些都是普通的 JavaScript 对象

39
00:02:22,160 --> 00:02:24,800
这些对象描述了应用中所发生的事情

40
00:02:26,680 --> 00:02:29,400
现在你已经了解了 Redux 的第二原则 ——

41
00:02:29,500 --> 00:02:31,340
状态是只读的

42
00:02:31,620 --> 00:02:36,020
唯一一个改变状态树的方式就是分发一个动作

43
00:02:36,520 --> 00:02:38,980
一个动作就是一个普通的 JavaScript 对象

44
00:02:39,100 --> 00:02:43,300
它以最简单的方式描绘了应用里面发生的改变

45
00:02:43,780 --> 00:02:48,500
无论是由网络请求还是用户交互发起的数据

46
00:02:48,620 --> 00:02:54,320
要想进入到 Redux 应用内部 都只能通过动作来实现
