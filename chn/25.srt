1
00:00:00,000 --> 00:00:01,280
在上一课里

2
00:00:01,280 --> 00:00:03,960
我们将 store 对象的变量声明删掉了

3
00:00:03,960 --> 00:00:08,920
转而将它作为属性传递给 TodoApp 组件

4
00:00:08,920 --> 00:00:11,200
所以   对于 TodoApp 里面的每一个组件

5
00:00:11,200 --> 00:00:13,660
store 都变成了一个属性

6
00:00:13,820 --> 00:00:17,440
甚至对于展示组件也是如此

7
00:00:17,440 --> 00:00:20,740
因为展示组件有时候会包含容器组件

8
00:00:20,740 --> 00:00:23,920
而容器组件需要监听 store 的变化

9
00:00:24,700 --> 00:00:27,400
要将 store 作为属性来传递

10
00:00:27,400 --> 00:00:30,020
我们需要写大量的模版代码

11
00:00:30,200 --> 00:00:31,780
但其实   我们有另外一种解决办法

12
00:00:31,780 --> 00:00:35,380
那就是 React 的高级特性“上下文(Context)”

13
00:00:36,440 --> 00:00:39,640
我现在要创建一个名为 Provider 的新组件

14
00:00:39,640 --> 00:00:44,560
它的 render() 方法只是单纯地返回子组件

15
00:00:44,560 --> 00:00:47,860
所以   我们可以将任意组件

16
00:00:47,860 --> 00:00:49,860
包裹在 Provier 组件中进行渲染

17
00:00:50,940 --> 00:00:53,140
这里我会修改 render() 的代码

18
00:00:53,140 --> 00:00:57,300
让它在 Provider 里面渲染一个 TodoApp 组件

19
00:00:57,820 --> 00:00:59,940
而且我还要将 store 对象

20
00:00:59,940 --> 00:01:02,980
从 TodoApp 移到 Provider 的属性里面

21
00:01:03,800 --> 00:01:08,300
Provider 组件会运用 React 的上下文特性

22
00:01:08,300 --> 00:01:13,740
让 Provider 的所有后代组件都可以访问 store 对象

23
00:01:14,060 --> 00:01:14,920
要做到这一点

24
00:01:14,920 --> 00:01:17,000
Provider 组件需要定义一个特殊的方法

25
00:01:17,000 --> 00:01:19,000
名为 getChildContext()

26
00:01:19,120 --> 00:01:21,260
React 会调用这个方法

27
00:01:21,840 --> 00:01:25,600
而它所返回的对象的 store 属性

28
00:01:25,600 --> 00:01:29,380
就是 Provider 组件的 store 属性

29
00:01:30,260 --> 00:01:34,100
这样    Provider 就为它的后代组件定义了一个上下文

30
00:01:34,100 --> 00:01:39,320
而 store 对象则变成了这个上下文的一部分

31
00:01:39,320 --> 00:01:42,720
所以   TodoApp 组件以及它的所有后代组件

32
00:01:42,720 --> 00:01:49,800
都会接收到这个包含 store 对象的上下文

33
00:01:50,500 --> 00:01:54,500
不过   要使用上下文需要满足一个重要的条件

34
00:01:54,500 --> 00:01:55,860
这个条件就是

35
00:01:55,860 --> 00:01:59,340
定义了 getChildContext() 方法的类

36
00:01:59,340 --> 00:02:02,840
必须定义一个静态属性 childContextTypes

37
00:02:03,640 --> 00:02:06,420
这些只是普通的 React.PropTypes 的定义

38
00:02:06,420 --> 00:02:13,040
但 childContextTypes 对于使用上下文非常重要

39
00:02:13,040 --> 00:02:14,720
如果你不定义 childContextTypes

40
00:02:14,720 --> 00:02:17,660
没有任何一个子组件能够访问这个上下文

41
00:02:18,780 --> 00:02:22,640
目前为止   容器组件是通过属性来访问 store 对象的

42
00:02:22,820 --> 00:02:24,560
不过我们要修改代码

43
00:02:24,560 --> 00:02:27,440
让它们通过 React 上下文来读取 store

44
00:02:27,840 --> 00:02:31,460
我们只需要把 this.props 改成 this.context

45
00:02:32,360 --> 00:02:34,400
同样地   在 render() 方法里

46
00:02:34,400 --> 00:02:37,540
我们也要通过上下文来访问 store

47
00:02:37,560 --> 00:02:38,840
而不是通过属性的方式

48
00:02:39,660 --> 00:02:40,280
最后要提到的一点

49
00:02:40,340 --> 00:02:44,360
组件是可以选择是否接收上下文的

50
00:02:44,500 --> 00:02:46,580
你需要做的是

51
00:02:46,580 --> 00:02:49,840
声明一个特殊的静态属性 ContextTypes

52
00:02:49,960 --> 00:02:52,400
它和 childContextTypes 类似

53
00:02:52,400 --> 00:02:53,200
不过在这里

54
00:02:53,200 --> 00:02:56,100
我们要声明的是想"接收的"

55
00:02:56,100 --> 00:02:57,700
而不是“传递的”上下文

56
00:02:58,040 --> 00:03:00,800
如果你忘了声明 contextTypes

57
00:03:00,800 --> 00:03:04,180
组件是不会接收到相应的上下文的

58
00:03:04,340 --> 00:03:07,820
所以千万不要忘记声明它们

59
00:03:09,420 --> 00:03:13,040
那些没有 this 的函数组件要怎么办

60
00:03:13,680 --> 00:03:16,660
我们会发现  函数组件也会接收到上下文

61
00:03:16,780 --> 00:03:19,980
不过是通过函数的第二个参数

62
00:03:20,200 --> 00:03:23,260
所以   我会用 ES6 的解构语法

63
00:03:23,260 --> 00:03:25,260
从第二个参数中得到 store

64
00:03:25,260 --> 00:03:28,140
而第二个参数就是上下文

65
00:03:28,800 --> 00:03:31,020
就像类组件一样

66
00:03:31,020 --> 00:03:35,220
函数组件也需要添加一个contextTypes 属性

67
00:03:35,220 --> 00:03:38,600
以此来声明想接收的上下文

68
00:03:38,600 --> 00:03:39,620
在这个例子里

69
00:03:39,620 --> 00:03:42,400
我希望得到的是 Provider 组件中的 store 对象

70
00:03:43,040 --> 00:03:45,620
如果我忘了声明 contextTypes

71
00:03:45,620 --> 00:03:50,460
函数组件就无法获得对应的上下文

72
00:03:50,700 --> 00:03:53,860
所以在使用上下文时

73
00:03:53,860 --> 00:03:56,140
千万记得要声明 contextTypes

74
00:03:56,940 --> 00:03:57,600
最后

75
00:03:57,600 --> 00:03:59,840
们要将 FilterLink 组件中读取 store 的地方

76
00:03:59,840 --> 00:04:02,540
改成通过上下文的方式

77
00:04:02,820 --> 00:04:07,080
我现在要在 FilterLink 里面添加 contextTypes 的定义

78
00:04:07,160 --> 00:04:10,860
这样它才能接收到 Provider 中定义的上下文

79
00:04:12,020 --> 00:04:15,200
现在 FilterLink 可以从上下文里读取 store 对象了

80
00:04:15,200 --> 00:04:20,140
所以我要把使用属性方式读取的地方都删掉

81
00:04:20,140 --> 00:04:23,300
另外  我还要从 Footer 中删掉 store 属性

82
00:04:23,300 --> 00:04:25,840
因为 Footer 不再需要传递它了

83
00:04:27,100 --> 00:04:30,800
基于同样的原因

84
00:04:30,800 --> 00:04:34,400
我把 TodoApp 中的 store 属性也删除掉

85
00:04:34,960 --> 00:04:39,680
现在   我们不需要显式地通过属性传递 store 对象

86
00:04:39,680 --> 00:04:42,960
而是隐式地通过上下文传递

87
00:04:43,680 --> 00:04:47,860
让我们回顾一下如何使用上下文传递 store 对象

88
00:04:48,480 --> 00:04:54,340
我们在 Provider 组件中渲染 TodoApp

89
00:04:56,020 --> 00:04:59,900
Provider 组件会渲染我们传递给它的一切

90
00:05:00,040 --> 00:05:04,960
所以在这个例子中它渲染了 TodoApp 组件

91
00:05:05,900 --> 00:05:06,680
除此以外

92
00:05:06,680 --> 00:05:13,000
Provider 组件还为它的所有后代组件提供了上下文

93
00:05:13,960 --> 00:05:17,280
这个上下文只包含了一个属性 store

94
00:05:17,280 --> 00:05:22,680
它对应了原来我们通过属性来传递的 store 对象

95
00:05:23,480 --> 00:05:27,460
我们在 ReactDOM.render() 中将 store 对象传递给 Provider 组件

96
00:05:27,460 --> 00:05:30,080
而且   通过定义 getChildContext()

97
00:05:30,080 --> 00:05:35,260
我们让 Provider 的后代组件也可以读取到 store 对象

98
00:05:36,360 --> 00:05:39,340
要注意 childContextTypes

99
00:05:39,340 --> 00:05:41,340
要和 getChildContext() 的返回值一致

100
00:05:41,340 --> 00:05:43,740
也就是它的 store 属性

101
00:05:43,740 --> 00:05:45,840
必须是 React.PropTypes.object 类型

102
00:05:46,720 --> 00:05:49,460
要注意   如果想要将上下文

103
00:05:49,460 --> 00:05:51,460
通过树状结构传递下去

104
00:05:51,460 --> 00:05:53,460
childContextTypes 的定义是必不可少的

105
00:05:54,280 --> 00:05:55,240
这样做的好处是

106
00:05:55,240 --> 00:05:59,200
我们不需要通过中间组件来传递 store 对象

107
00:05:59,200 --> 00:06:00,120
取而代之地

108
00:06:00,120 --> 00:06:04,060
我们可以在需要读取 store 的容器组件里

109
00:06:04,060 --> 00:06:05,520
定义 contextTypes

110
00:06:05,680 --> 00:06:08,520
这样我们就可以从上下文里访问 store

111
00:06:08,520 --> 00:06:11,160
而不需要通过组件的属性

112
00:06:11,720 --> 00:06:15,100
在 VisibleTodoList 和 Provider 组件之间

113
00:06:15,100 --> 00:06:21,080
上下文就好像创造了一个虫洞

114
00:06:21,080 --> 00:06:25,280
而只有当 VisibleTodoList 的 contextTypes

115
00:06:25,360 --> 00:06:29,080
和 Provider 的 childContextTypes 一致时

116
00:06:29,080 --> 00:06:33,500
这个虫洞才会开启

117
00:06:35,020 --> 00:06:39,100
AddTodo 是另一个需要访问 store 对象的组件

118
00:06:39,100 --> 00:06:43,140
所以   它也定义了 contextTypes

119
00:06:43,140 --> 00:06:45,560
以此来接收上下文

120
00:06:46,480 --> 00:06:47,240
这就是为什么

121
00:06:47,240 --> 00:06:50,580
除了 props 以外   AddTodo 还接收了第二个参数

122
00:06:50,580 --> 00:06:52,580
也就是上下文

123
00:06:53,240 --> 00:06:55,280
这里我是用 ES6 的解构语法

124
00:06:55,280 --> 00:06:58,060
以此来接收上下文

125
00:06:58,780 --> 00:07:00,820
上下文在树结构的任何深度都可以访问

126
00:07:00,820 --> 00:07:04,680
所以我们不需要在 Footer 里定义 contextTypes

127
00:07:05,200 --> 00:07:08,800
FilterLink 才是那个需要直接使用上下文的组件

128
00:07:08,800 --> 00:07:13,000
所以我们只需要在 FilterLink 里面

129
00:07:13,000 --> 00:07:17,120
定义 contextType 就可以了

130
00:07:19,260 --> 00:07:21,320
上下文是个非常强大的特性

131
00:07:21,320 --> 00:07:26,080
但从某个角度它违反了 React 的显式数据流的哲学

132
00:07:26,780 --> 00:07:31,400
上下文其实就是让全局变量成为了可能

133
00:07:31,400 --> 00:07:34,540
不过全局变量通常不是一个好的做法

134
00:07:34,540 --> 00:07:37,980
所以  除非你需要进行依赖注入

135
00:07:37,980 --> 00:07:38,800
就像在这个例子里

136
00:07:38,800 --> 00:07:42,600
所有的部件都需要能够访问一个单一的对象

137
00:07:42,600 --> 00:07:45,640
否则你不应该使用上下文

138
00:07:46,360 --> 00:07:46,860
还要说一句

139
00:07:46,860 --> 00:07:49,700
React 的上下文 API 处于不稳定的阶段

140
00:07:49,700 --> 00:07:53,060
它之前被修改过   之后还可能被再次修改

141
00:07:53,060 --> 00:07:56,280
所以不要对它太过依赖

